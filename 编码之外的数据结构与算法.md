# 关于后续更新

后续所有更新均在微信公众号统一发布：扫描下方二维码关注，不迷路😎

![https://img-blog.csdnimg.cn/20200106120314187.png](https://img-blog.csdnimg.cn/20200106120314187.png)

## 感谢阅读

大学的时候选择了==自学Java==，工作了发现吃了==计算机基础不好==的亏，==学历不行==这是没办法的事，只能后天弥补，于是在==编码之外==开启了自己的逆袭之路，***不断的学习Java核心知识，深入的研习计算机基础知识***，所有心得全部书写成文，***整理成有目录的PDF，持续原创，PDF在公众号持续更新***，如果你也不甘平庸，那就与我一起在编码之外，不断成长吧！

其实这里不仅有技术，更有那些技术之外的东西，比如，如何做一个精致的程序员，而不是“屌丝”，==程序员本身就是高贵的一种存在啊，难道不是吗？==

非常欢迎你的加入，未来的日子，编码之外，有你有我，一起做一个==人不傻，钱很多，活得久==的快乐的程序员吧！

***回复关键字“PDF”，获取技术文章合集，已整理好，带有目录，欢迎一起交流技术！***

**另外回复“庆哥”，看庆哥给你准备的惊喜大礼包，只给首次关注的你哦！**

任何问题，可以加庆哥微信：H653836923，另外，我有个交流群，我会***不定期在群里分享学习资源，不定时福利***，感兴趣的可以说下我邀请你！

==对了，如果你是个Java小白的话，也可以加我微信，我相信你在学习的过程中一定遇到不少问题，或许我可以帮助你，毕竟我也是过来人了！==

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200204002231750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

感谢各位大大的阅读🥰

# 熬夜写的数据结构与算法学习指南，可能是最适合新手的了！（附赠资料）



## 先来聊聊学习数据结构与算法
不知道你们是肿么样，**反正我大学的时候数据结构与算法那是惨的一批**😂，不怕告诉你，当初数据结构60分刚刚及格，至于为啥刚刚60分，那我心里还不跟明镜似的，唉，当初上这个课，那跟听天书似的，讲的是个啥，完全搞不懂啊，你见我当时的书：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312223705465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
我就不告诉你，这是我趴上面睡觉压的😂，怪尴尬的，反正我这块差的一批，自己之前虽然一直在自学，但是这块还真没有咋下功夫，后来去面试的时候，凡是这块的问题，我就都忽略了，完全不会啊，我也很无奈啊🤣

为啥会这样？反正吧，有一半的自身因素，也有一半的环境因素，不过这都过去了了，**好汉不提当年衰啊**，不过这次我可是铁了心，要搞定数据结构与算法了，我知道，肯定有很多和我一样的，上大学的时候没有好好学，导致现在自己在这块是个大大的短板，没事没事，接下来的日子，**咱们一块来学习数据结构与算法，我会从零到一的去学习，去写文章，去与大家交流分享……**

### 数据结构与算法，听起来就难得不要不要的
数据结构与算法真的是那种听起来就让人闻风丧胆的吗😂，为啥大家都觉得它难嘞？我觉得吧，有一部分原因是大家大学的时候都学过，可是当时真的听不懂，所以就**形成了一种思维定式，就觉得这玩意难**，后来嘞，需要学习的知识越来越多，而我们人呐，往往会优先选择那些做起来简单的，因此，很大一部分人在后来的学习中就把数据结构与算法给搁置了……

还有就是，我们在后来的工作与学习中可能也有好多次去学习数据结构与算法，但是当自己真正的去接触这玩意的时候，我去，还真的有难度啊，怪不得很多人都说数据结构与算法难，看来是真的……

然后嘞，我们其实实际的工作中，一般化的，用到数据结构与算法的时候真的蛮少的，学习的性价比不高啊，也就面试的时候有时候会考考，那就临时抱佛脚呗，也能搞定面试……

那么数据结构与算法，到底难吗？说实话，难，因为很抽象，也复杂，再加上我们的思维定式，没有形成系统化的学习与练习，很多人呐，这块都是短板，**尤其新手这块，知道这块重要，但是完全弄不着头脑啊……**

## 数据结构与算法，到底该怎么学？😂
可能有人说了，我也知道啊，数据结构与算法很重要，我也想学习啊，但是就是觉得无从下手啊，咋办，我也很彷徨啊😂

真实真实，太真实了，也太扎心了🤣

别说你，其实很多人刚开始不都是这样吗？那接下来我就告诉你学习他们的秘籍，首先嘞，我需要你先记住这句话，这也是一个学习秘籍啊，那即是：

> 知识在于积累，学习需要耐心！

这句话说的贼好！其实很多人都是这样的，我们一开始学习一个知识点，都会感到无从下手，不知道该怎么去学，俗话说，万事开头难，这话是真的，大部分人真的就是开始还没有就结束了。

**很多人的学习数据结构与算法就是这样，还没开始就结束了……**

接下来我就说说关于学习一些编程知识的法宝秘籍，不要外传哦，对了我以下要说的其实不是针对数据结构与算法，对于学习其他知识也是很有参考意义的。

## 通用性建议---如何学习编程知识？
### 1、你需要的不是一个参考

我们有时候学习一个知识点，一定会去找一些学习资源，这是一个输入的过程，这个过程一定要是尽量的多而全，就比如我们学习数据结构中的链表，我们学习的话，可以多看看基本相关书籍上对这个知识点的介绍，然后再去网上看看别人写的博客以及别人学习的心得，有了这些，你就要自己去思考，甚至去实践，把这些知识点吸收内化，然后用自己的话表达出来，这可以是笔记，更可以是博客，而我建议是你把它写成博客，学习一个知识，其实就是这样！


### 2、不要钻牛角尖

这个啥意思嘞？就是有的时候啊，我们学习一定会碰到自己不会的，而且这个问题自己一时半会还解决不了，如果这要是在工作中的话，你最好赶快找人求助，因为这是你的工作任务，不能完不成，更不能因此而耽误你的整体工作进度，但是，如果是我们私底下学习的话，有的时候遇到实在理解不了，搞不定的，我们真的没有必要非得当下一定要把它搞懂，比如有些人学习递归，就是看不懂，不理解，还非要跟自己较劲，把自己整的垂头丧气的，大可不必如此，放下它，学学其他的，甚至你可以打把游戏，说不定下次再看，就恍然大悟了，你还别不信，有的时候真的是这样。


### 3、一定要多交流

其实吧，说起这个很尴尬，因为我有体会啊，交流其实蛮重要的，但是，真正的交流其实很少，别说现在有各种各样的群，但是你如果去问问题的话，大概率没人鸟你，所以所谓的技术交流群在我看来很多都是扯淡，然并卵的存在，这个一直是个问题，其实吧，这也是我的短板，这块我一直在想办法，也一直在试错，别担心，有成果我一定会第一时间告诉你们，在此之前，你们依然可以去水各种群，另外还一个行之有效的方法，找人私聊请教！


### 4、你得多动手（不是让你找人打架）

这点我觉得吧，很多人都知道，但是做的人真心不多，包括我，我这块做的就不好，**有的时候觉得自己那么渣也是有原因的😂**，编程这玩意，真的得多动手实践，说白了，你得多敲代码，看是一回事，懂了又是一回事，但是，只有你真正的自己能够动手敲代码搞出来，那才叫没事，之前很多人给我说，庆哥庆哥，为啥我看书或者看视频当时自己看懂了啊，可是敲代码的时候就一脸懵逼，别说你，有的时候我也是一脸懵啊，为啥，还是你敲的少，第一次敲不出来，抄总可以吧，抄的多了，你就记住了，再敲……

**数据结构与算法的学习更是如此，后期我会带着大家进行大量的实战，其实这块你不用操心，跟着庆哥我就行了，因为我也是要学习的。**

再记住一句话：

> 纸上得来终觉浅，绝知此事要躬行！

**没有人可以一蹴而就，付出总归会有回报，越努力与幸运！**

以上说的这几点，其实可以运用到你学习的任何知识，我们学习啊，有个很重要的能力，那就是触类旁通，举一反三啊，好好理解我上面说的几个，对你学习数据结构与算法是很有帮助的哦。

接下来我们继续针对数据结构与算法的学习来说说。

## 那么针对数据结构与算法该怎么学习？

> **先搞数据结构，再搞定算法**

我之前写了好几篇关于数据结构的文章了，一个心得，那就是一定要画图（学习数据结构的饿时候），很多人觉得数据结构难，很大一个原因就是这玩意比较抽象所以学习的时候，自己动手画画图，你要在自己的脑海中把这些数据结构的样子给固定下来，说到哪个数据机构，脑海中要立马想到，这玩意长啥样，这是最基本的一步。

也就是说啊，前期我们开始学习数据结构的时候，自己一定要多动手画画图，这真的有助于你理解。数据结构这块嘞，其实那就要学会那些基本的几个，也就是栈，队列，数组，链表这些，当我们把这些基本的数据结构学的差不多了，这个差不多是咋回事嘞，啥是个差不多嘞，那就是它是个啥你得知道，然后最好自己动手用自己会的语言把它们实现一遍，也就是基本的那些增删改查啥玩意的，然后就是数据结构的进一步学习了，我们就可以进行专题形式的做题，也就是多做一些数据结构相关的题目，这个时候可以去一些刷题网站。

这个时候基本数据结构你都差不多了，那么做题的同时就可以搞算法了，有的人建议算法这块直接刷题就行了，毕竟基本的数据结构都差不多了，但是吧，我觉得你只会数据结构，还不适合直接去刷算法题，最起码你得会一些常见的算法思想，比如递归，枚举和动态规划啥的吧，而且这些还不是那么容易学得懂的知识。

所以啊，我觉得刷题的最佳时机就是你把数据结构和算法的基础知识都给学了，也就是那些基础的，大众熟知的，你该会的都得会啊，然后就可以大量做题刷题，这样你的数据结构与算法能力就会不断提升了。

**总结起来就是先搞定数据结构，概念啥的必须会，要有自己的理解，然后自己动手实现一遍，多画图，然后多做题，接着学习一些常见算法，理解其常用算法思想，然后结合数据结构，大量刷题，不断进阶打怪……**

> 到了这里，再给你说点实在话，也许你看了我上面说的，觉得内心信心满满，决定我要开干了，但是，大部分也都是三分热度，然并卵的存在，如果你真的有计划学习数据结构与算法的话，你之前肯定看过不少这块的经验之谈了，可是你又做了多少嘞，正所谓，懂得了很多道理，却依然过不好自己的一生……

不过没关系，你不用费那么大劲，关注庆哥，跟着我一块学习就对了，毕竟，咱们2020的目标，就是搞定数据结构与算法，你只要按时学习我发布的文章，有问题留言交流就ok了，而我，尽量用大白话去给你讲解这些晦涩难懂的知识。

> 这块估计有些朋友还不了解，我搞了个公众号，主要就是带着大家学习Java，我这个学习很特殊，就是我会和读者们定期制定一个学习目标，然后集中一段时间对这个知识点进行专题形式的学习，就是系统化的把这个知识点学习一遍，而且所有文章我还会整理成PDF供大家下载学习，2020，我们就搞数据结构与算法，很适合新手们，因为我写的文章大家都说特别容易理解！感兴趣的，微信搜索“编码之外”，或者加我微信H653836923，咱们一起交流学习数据结构与算法！

接下来就是重点啦，那就是数据结构与算法，我们该学习哪些东西呢？针对我们这种患有严重技术焦虑的人，学习一个东西之前，一定要有个学习规划，你得知道你每天要搞啥，搞完这个接下来该搞啥，所以对于数据结构与算法这块的学习，我们得明白自己需要学习哪些东西，自己心里先有个普。

## 我们需要学习哪些知识点？（附有思维导图）
如果我们决定要开始学习数据结构与算法了，除了知道一些基本的学习技巧之外，比如上面我分享的，然后知道一些大概的学习步骤，那具体的我们该学习哪些知识点嘞？这个蛮重要的，经过我的多方收集与咨询，最终确定了如下这些你必知必会的知识点，先来个图吧：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312231022269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
看起来是不是没有多少东西啊，咋一看确实如此，但是实际上啊，有些点我没有展开来讲，不然包含的东西太多了，我怕把你吓跑了，接下来我就简单的做一下介绍：

### 基础中的基础
#### 复杂度
想必了解过数据结构与算法的，一定听说过时间复杂度和空间复杂度吧，也就是那什么大O表示法，这个可以说是学习数据结构与算法必备的一个知识点，理解它，非常有必要，这是最基础的一步，后面很多算法，我们都要去衡量它，那就需要这个知识，我之前写了一篇，你可以先去看看：

[听说数据结构与算法中的复杂度很难理解？看看这个吧！](https://blog.csdn.net/sinat_33921105/article/details/103540890)

#### 基础的数据结构
这块就是我们最开始进行学习的了，也就是我们必须要掌握的那些个数据结构，主要有：

1. 数组
2. 链表
3. 栈和队列
4. 哈希表
5. 字符串
6. 树
7. 图

其实吧，这里你一定要重点关注的就是数组和链表，为啥嘞，因为其实很多其他的数据结构，比如栈和队列，哈希表啥的，其底层还是数组和链表，也就是说啊，数组和链表是数据结构中的数据结构。

另外像树和图，展开的内容相对较多，也比较难，这个没事，我们以后慢慢一起学习，争取都给它搞懂，我此前也写了一部分，你们可以先看看，是否能够看得懂，可以给我留言或者直接加我微信，咱们一起交流哦

[来吧！给你不一样的数组深入讲解！](https://blog.csdn.net/sinat_33921105/article/details/103453679)

[链表不会？看这个立马就懂！](https://blog.csdn.net/sinat_33921105/article/details/103434447)

[轻轻松松学会栈和队列（附有顺序栈的实现思路分析）](https://blog.csdn.net/sinat_33921105/article/details/103673904)

[来吧！一文彻底搞定哈希表！](https://blog.csdn.net/sinat_33921105/article/details/103344078)

[来吧！一文彻底搞定数据结构之树！](https://blog.csdn.net/sinat_33921105/article/details/103966050)

[看了这篇对二叉树的介绍，除了不会写代码啥都会！！！](https://blog.csdn.net/sinat_33921105/article/details/104203893)

[Java代码实战：通过手写一个单链表，告诉你学习编程的方法和捷径！](https://blog.csdn.net/sinat_33921105/article/details/104402253)

有不懂的记得联系我哦！

#### 那些需要了解的算法
说到算法这块，就有点高深了，最起码很多人都这样觉得啊，不信你看看这些词：

1. 贪心算法
2. 分治法
3. 动态规划
4. 回溯与递归
5. 分支限界法
6. 线性规划网格流

你看看，我都觉得这是本武功秘密啊，各种内功心法，大家都说，数据结构与算法就是每个程序员的内功，我觉得这话一点也不假啊，就冲着名字，也不骗你们啊。

而且啊，这其中每一个展开来都有很多的内容，比如贪心算法中的最优装载问题，还有背包问题和最小生成树等等。

然后还有分治法中的二分搜索技术和一些排序的问题，另外还有动态规划中的0-1背包问题……

反正吧，牵涉到算法，那其实就是默认你已经搞定数据结构了，这时候就是上升到一个思想和整体的应用层面了，我们学习的面也变广了，当然，学习的内容多了，可能也变得更难了……

不过这才有挑战嘛！

## 来个总结吧
其实我还是想和大家说：

> 即使懂得了很多道理，但未必过得好自己的一生

啥意思嘞，想必大家一定看多各种学习指南，方法与经验，当时看的时候如获珍宝，但是自己实际上好像啥也没做，其实吧，还是不知道该怎么做，就像我上面说的那些，也许你们看了，觉得有用，有指导意见，一些新手可能会说，我可以跟着这个指南来学习，但是相信我，你撑不过三天，依然觉得迷茫，彷徨，有难度……

你可能会说，那么扎心的吗，现实就是如此啊，不是我扎心，说白了，很多人的自学能力很差，这表现在自己的自控自律与自我规划都不行，这是我们所受的教育决定的……

那你可能要问了，那咋办，我还要学习数据结构与算法嘞，没事啊，我都说了，我会从零到一的写一份适合新手从零开始不断进阶的数据结构与算法的教程，其实说白了，我是与大家一起学习，只不过我写你们看，你们反馈，我们交流，大家一起不断试错，一起进阶，2020，我的目标就是要搞定数据结构与算法！

感兴趣的来哦，在公众号可以获取整理好的PDF，方便你们学习！

## 整理了20本经典数据结构与算法书籍送给你们
**话不多说，免费送给你们，在我的公众号后台回复“数据结构与算法”即可获取！**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312235338556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
## 感谢阅读

大学的时候选择了==自学Java==，工作了发现吃了==计算机基础不好==的亏，==学历不行==这是没办法的事，只能后天弥补，于是在==编码之外==开启了自己的逆袭之路，***不断的学习Java核心知识，深入的研习计算机基础知识***，所有心得全部书写成文，***整理成有目录的PDF，持续原创，PDF在公众号持续更新***，如果你也不甘平庸，那就与我一起在编码之外，不断成长吧！

其实这里不仅有技术，更有那些技术之外的东西，比如，如何做一个精致的程序员，而不是“屌丝”，==程序员本身就是高贵的一种存在啊，难道不是吗？==

非常欢迎你的加入，未来的日子，编码之外，有你有我，一起做一个==人不傻，钱很多，活得久==的快乐的程序员吧！

***回复关键字“PDF”，获取技术文章合集，已整理好，带有目录，欢迎一起交流技术！***

**另外回复“庆哥”，看庆哥给你准备的惊喜大礼包，只给首次关注的你哦！**

任何问题，可以加庆哥微信：H653836923，另外，我有个交流群，我会***不定期在群里分享学习资源，不定时福利***，感兴趣的可以说下我邀请你！

==对了，如果你是个Java小白的话，也可以加我微信，我相信你在学习的过程中一定遇到不少问题，或许我可以帮助你，毕竟我也是过来人了！==

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200204002231750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

感谢各位大大的阅读🥰

# 我一直没搞懂数据结构到底是个啥？直到看到这篇文章！

## 抱歉，我真的学不会

> 又要说起我的血泪史了😂

我当初上大学学习数据结构是学的这本教材：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314224748475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)


应该有不少伙伴都是学的这本吧（**完了，上篇文章一发，大家都知道我数据结构60分了，没法混了🤣**），最近啊，有许多小伙伴知道我要连载数据结构与算法系列，就跑过来私信给我“庆哥啊，这数据结构真的搞得我头大，这都是啥啊😂”



不怕你笑话，我大学四年都没有搞懂数据结构这玩意到底是个啥？😂（我真的有那么笨吗？尴了个大尬）

上大学那会，总觉得这玩意太抽象，学不明白，越往后学越跟不上，还没到一半就掉队了，基本上属于放弃治疗的那种，后来知道啊，这书上写的都是伪代码，我说怎么把我看得一愣一愣的，就这样，整个四年大学，我愣是没有搞懂数据结构是个啥？

然后嘞，那些搞懂的，顺利参加校招，拿到满意offer，进入大厂，迎娶白富美……而我呢？

面试官：“数据结构有了解吗？”

我：“啥？你说啥？数据结构是个啥？”

然后我就顺利毕业了……

**扎心不，老铁？**你是不是也是这样啊，正在读大学，数据结构也是一脸懵逼，或者毕业了，还是不知道数据结构到底是个啥，说出去怪尴尬，没事，看了今天这篇文章，保准你可以出去大声喊“我……终于……知道……数据结构是个啥啦”（拉长音……）

## 数据结构你到底啥玩意啊？

第一次接触“数据结构”的时候，觉得有点抽象，不过觉得也没有那么难理解，嗯嗯，应该是这样的，谁知道，越学越迷糊，咱们先看看，这个数据结构怎么定义的：

> 数据结构是相互之间存在一种或多种特定关系的数据元素的集合，换句话说，数据结构是带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系。

不知道大家看到这段定义什么感觉，反正我当时看着有点迷糊，不过我现在再来看，觉得说的挺好的。

### 聊聊数据在计算机中的存储 

要想比较好的理解数据结构，你得先了解数据在计算机中的存储，我们举个简单的例子，比如我们要存储一个数字，比如1024吧，怎么存储嘞，我们知道，一般这样写代码（java））：

```java
int a = 1024;
```

也就是定义一个整型，我们写完它，是保存在我们的电脑上，实际上是保存在了我们电脑中的硬盘中，程序要加载进内存才可以被CPU读取运行，所以啊，这个1024实际上得装载进内存中，这里需要说明的是，这个1024是我们写的一个程序中的一个整型变量，你还得明白的是，我们这里说它保存在内存中，是因为要运行这段程序了。

一旦运行这段程序，这个程序中包含的数据就要装载进内存中，就好比这里的1024，也要保存进内存，那么它怎么保存嘞？这里你还要记住这么一句话：

> 计算机中的数据都是以二进制的形式保存的

因此嘞，这个1024是十进制，要转换成二进制保存在内存中，内存有一定的大小，你要保存一个整数，你是不是得占用内存的一些空间啊，假如是这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314231446907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)


你看，这样这个1024就被存在了内存中，当然，你得明白，这个1024其实被转换成了二进制形式，我这样只是为了便于表示说明。

这块不了解的可以看看我之前写的这几篇文章：

[一个程序在计算机中是如何运行的？超级干货！！！](https://blog.csdn.net/sinat_33921105/article/details/104047172)

[作为一个程序员，CPU的这些硬核知识你必须会！](https://blog.csdn.net/sinat_33921105/article/details/104066631)

[作为一个程序员，内存的这些硬核知识你必须懂！](https://blog.csdn.net/sinat_33921105/article/details/104111467)

[作为一个程序员，内存和磁盘的这些事情，你不得不知道啊！！！](https://blog.csdn.net/sinat_33921105/article/details/104142623)

### 再来说数据结构 

了解了数据在计算机中大致怎么存储以后，我们就可以再来看数据结构这家伙了，定义我们之前看过了，怎么去理解嘞，数据结构从名字上看，就是数据和结构，结构可以理解为关系，就是数据之间存在什么样的关系……

这样说，你其实还是有点迷糊，你可以这样理解，首先嘞，你先清楚，数据结构啊，它是一门学科，干啥的嘞？说白了，**就是研究数据该怎么存储？**

你可能说了，还研究怎么存储，难道存储不都是一样的吗😂，虽然这个问题有点chun，但是嘞，确实是个让小白疑惑的问题，数据的存储当然是不一样的啊，举个例子吧，假如我们要存储一个五个整数{1，2，3，4，5}，你内存中咋么个存储，可能是这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314233624664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)


啥意义嘞？就是这五个数字啊，在内存中是排成一排的，一个挨着一个，但是有可能也是这样的：



![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314233924530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)


就是在内存中没啥顺序，零散的存放，所以啊你看，对于数据，可以按照不同的方式去存储，是给你连续挨着存放，还是存放在哪就存放在哪啊，你可能要问啦，哪这咋整，这个嘛，就得看数据本身以及其他相关要求，看看你这个数据以后准备怎么用，然后考虑怎么存放比较合适。

所以啊，数据结构啊，就是来管理数据在内存中的存储的，比如，有一些数据要在内存总存储，那就得看数据结构，数据结构让你怎么存放你就得怎么存放，让你连续存放，你就不能撒花似的哪都是的。

另外啊，你还需要知道，这里的数据结构是个统称，就好比水果，它有香蕉苹果和橘子，数据结构也是一样啊，它是个总称，有数组，链表，栈和队列等等，这些都属于数据结构，就好比，香蕉苹果和橘子都是水果，这个好理解吧！

然后嘞，这些数据结构啊，每个都有它们自己的一些特点，这些特点就是规定如果数据选择了它这种数据结构来存储，就要按照它的要求在内存中存放，比如你选择了数组，那么你这些数据就要在内存中连续存储，一个挨着一个，不能乱，而如果你选择了链表这种存储结构，那在内存中就不要求你非得连续存储，随意，有空地你就可以存储。

所以你看，不同的数据结构有它特定的用途……

到了这里，你差不多就理解了数据结构是个啥了吧，也就是说啊，数据结构就是研究数据怎么存储嘞，然后数据结构是个总称，好比水果，其下有数组，链表，栈和队列这些数据结构，好比水果有香蕉苹果和橘子，其实嘞，你就可以把数据结构想象成一个容器，容器是干啥的嘞，盛东西的啊，这里就是存储数据的，而这些容器形状各异，你选择了不同的容器（数据结构），那么就意味着数据的存储形式是不同的。

说了那么多，到此为止了嘛？当然不，而且差的还远着嘞😂，我们上面说的存储的五个数据，可以想象的到，这五个数据之间并没有啥联系，顶多就是连续存储的时候，一个挨着一个，这样存在一对一关系，也就是跟站队似的，你前面有我，我后面有你。

但是还有一种数据，比如我们要存储一个家谱中的数据信息，比如这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200315000452744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)


你想一下，如果是这样的话，怎么存储到内存中嘞？这些不同于那些冷冰冰的数字，保存进内存就万事大吉了，这种家谱数据我们保存的时候其实保存的不仅仅是数据，最重要的是还要保存各个数据之间的关系。



经过上面的介绍，想必你肯定知道个小大概了，那就选择一种数据结构来存储它呗，说的不错，我们分析家谱数据可以发现，这些数据拥有一对多的关系，比如爷爷有三个儿子，大伯有两个小孩，像这种数据，数据结构中有一种结构叫做树的是可以保存这样的数据的。

我们上面说的这些一对一，一对多都是表示数据之间的关系，其实也就是数据结构中的结构，这里可能有人问了，那有没有多对多的关系呢？答案肯定是有的，那么这种该怎么存储嘞？没事，数据结构中还有个叫图的，就是专门针对多对多的数据的。

所以你看，数据结构是个啥，不就是管着数据该怎么存储嘛？

## 数据结构都有哪些嘞？

那么，你肯定好奇，那么，数据结构都有哪些啊？数据结构总的来说有如下三大类：

- 线性表，也就是数组、链表、栈和队列； 
- 树结构，包括普通树，二叉树，红黑树等等；
- 图存储结构，这玩意有点难😂；

接下来我对这些数据结构做一下简单的介绍。

### 线性表 

线性表其实也是个统称，它包含顺序表和链表，还有栈和队列这些，线性表其实好理解，线性一词就很明白了，说明数据都是一对一的关系，存储的形式也都是依次排列。

这里说到依次排列，可能有人会在数组和链表这里犯迷糊，数组很明确，需要连续的内存空间，数据连续存放，一个挨着一个，说这是依次排列，那ok，可是链表嘞，不是说链表不要求非得连续排列嘛？是的，确实如此，但是链表实际的存储为了保持这种依次排列，它引入了指针，就比如这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200315002516760.png)
数组是这样的：



![在这里插入图片描述](https://img-blog.csdnimg.cn/20200315002546545.png)

所以啊，链表也是线性表，也是依次排列的，这个要理解，另外这里你可能也会听到顺序表这个概念，初学者的话，你就可以把顺序表等价为数组，听我的没错。

然后就是栈和队列了，这俩也是线性表，只不过是比较特殊的线性表，它们对数据的进出做了明确的要求，这里我就不多说了，我之前写文详细了介绍了这些线性表，你们可以看看：

[来吧！给你不一样的数组深入讲解！](https://blog.csdn.net/sinat_33921105/article/details/103453679)

[链表不会？看这个立马就懂！](https://blog.csdn.net/sinat_33921105/article/details/103434447)

[轻轻松松学会栈和队列（附有顺序栈的实现思路分析）](https://blog.csdn.net/sinat_33921105/article/details/103673904)

[来吧！一文彻底搞定哈希表！](https://blog.csdn.net/sinat_33921105/article/details/103344078)

[来吧！一文彻底搞定数据结构之树！](https://blog.csdn.net/sinat_33921105/article/details/103966050)

[看了这篇对二叉树的介绍，除了不会写代码啥都会！！！](https://blog.csdn.net/sinat_33921105/article/details/104203893)

[Java代码实战：通过手写一个单链表，告诉你学习编程的方法和捷径！](https://blog.csdn.net/sinat_33921105/article/details/104402253)

### 树结构 

其实我觉得，越往下，是越难的，像树结构就比线性表难一点，不过也是，线性表是一对一的数据关系，而树结构就是一对多了，肯定会复杂一点。

说到树啊，什么二叉树，红黑树，B+树等等，这些都是重点知识，而且学起来我觉得都有点难度，说实话，数据结构与算法真的有难度，不过别担心，跟着庆哥我，别掉队，今年咱们一起拿下它。

那么树结构啊，我们上面也说了，就是存储那些具有一对多关系的数据，典型的有家谱啊，公司组织架构啥的，反正数据之间具有一对多，满足这种关系就可以使用树结构来存储。

### 图结构 

自然而然，图结构就是存储那些具有多对多关系的数据，这自然比前两者都要复杂的多，学起来也是有挑战的啊，它大概是这么一个关系：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200315003642404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)

## 数据的逻辑结构与物理结构

经过我们上面的介绍，相信你已经get到不少干货了，那么接下来还要继续为你不一些硬货，那就是关于数据的逻辑结构和物理结构。

到这里我们已经知道了什么是数据结构，以及都是有哪些数据结构，我们上面也做了简单的分析，说了说各个数据结构，那么你有没有想过，我们该如何选择这些数据结构去存储数据呢？上面也提到过，那就是要看数据本身了。

实际上，对于数据的存储该选择什么样的数据结构，那就要取决于数据的**逻辑结构和物理结构**，再次声明下，这点的理解很重要，以下我说的每个字都不要漏掉哦😁                      

### 啥是逻辑结构？ 

不知道你们之前有没有想过这个问题，数据的逻辑结构是个啥？可能你有点迷糊，但是说起来真的很简单：

> 数据的逻辑结构就是指的数据之间存在的关系

我想经过上面的讲解，你这里立马就知道，这里指的关系就是上面说的什么一对一，一对多和多对多了，不错，就是这些，这里的数据的逻辑结构指的就是这么些个关系，就好比我上面给的那个图，我们再来看一下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200315000452744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
比如上图中的大伯，二伯和爸爸，他们都属于兄弟关系，爷爷有三个儿子，大伯有两个孩子，这就是一对多的关系，像这种数据，我们要存储的话，不仅要存储基本数据信息，更重要的也要存储着他们之间存在的关系。



而这种关系就是数据之间的逻辑结构。

这里总结一下，数据之间的逻辑结构大致分为三种，也就是：

1. 一对一：就是那种你挨着我，我挨着你的数据，比如数组
2. 一对多：就是我们上面画的家谱图那样
3. 多对多：这个比如说地图，或者一些四通八达的路，能明白我的意思吧😂                 

其实吧，给到你一些数据，你基本上都能判断出这些数据是什么关系，也就是说，数据的逻辑结构不难辨认。

到了这里，你有没有发现，这三种逻辑结构的数据，正好可以用我们上面介绍的三大类的数据结构去存储，想一下，也就是下面三种：

1. 线性表：一对一
2. 树结构：一对多
3. 图结构：多对多

有没有发现，万变不离其中啊，只是我们了解了逻辑结构这个知识点后，你会觉得这块的只是更加的完整。

### 物理结构又是个啥？ 

#### 重要知识点

我们在上面知道了啥是逻辑结构，那么我们就可以分析数据之间的逻辑结构来看看数据该选用哪一种数据结构来存储，这看似已经万事大吉，没啥事了，但是，实则不然，其实吧，说到这里，牵涉到的知识点又不少，我这里只给你说重点，详细的以后单独拿出来唠叨唠叨。

你先记住这非常重要的一句话：

> 数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）。

啥意思嘞？其实吧，**数组和链表是数据结构中的数据结构，其他的数据结构都可以用数组和链表来实现**，你比如拿栈来说吧，可以用数组来实现栈，这就叫做顺序栈，也可以用链表来实现栈这个就叫做链式栈。

**所以啊，每种数据结构的存储其实都可以分为顺序存储（用数组实现）和链式存储（用链表实现）**            

你比如说要使用队列这个数据结构来存储数据，那实际上，就可以分为顺序队列实现和链式队列实现，也就是看你实际内存中怎样去存储这些数据，因此，你可以看出，**数组和链表是数据结构中的基石啊！** 

那么，新的问题就来了，既然对于每个数据结构都可以有顺序存储和链式存储，那么即时我依据数据的逻辑结构选择了一个数据结构，那么我怎么来确定是要顺序存储还是要链式存储呢？

> PS：上面的这个问题很重要，你一定要理解，不理解的把上面几段话多读几遍，一定要理解，一定要理解！

这个问题的关键所在就是要分析数据的物理结构了？

#### 再看物理结构

那啥是数据的物理结构呢？同样的，如果你之前没有想过这个问题，同样会觉得迷糊，但是其实也是很简单的：

> 数据的物理结构就是指的数据在内存中的存储是连续存储，也就是集中在一块的意思，还是零散的分散存储。

也就是说啊，对于一些数据，我们分析得出他们之间的逻辑结构，知道了数据之间具有什么样的关系，这个我们可以确定数据结构了，但是我们还要分析数据的物理结构，可是，你有没有发现问题，我们怎么知道数据的物理结构是啥呢？

这里要看两点，来让我们决定数据的物理结构，分别是：

1. 内存的空间状态
2. 数据的用途

啥意思嘞？我们拿内存空间的状态来说，首先啊，我们得知道，连续存储要求有连续的内存空间，比如我们要存储10M大小的数据，那就是要求内存中也要有一整块空间是10M，但是如果没有的话那肯定是用不了连续存储了，那只能分散存储，否则存储不成功啊。

再来看数据的用途，对于连续存储和分散存储主要的一个区别就是会影响到后续数据的操作，就拿连续存储来说，它对数据的遍历效率比较高，因此，如果你存储的这些数据后续的操作中遍历比较频繁，那肯定优先选择连续存储，当然，如果你后续的数据操作中会进行比较多的更新操作的话，那就优先选择分散存储了，因为它效率更高。

所以我们根据**内存的空间状态**和**数据的用途**来确定数据的物理结构是连续存储还是分散存储，然后再选择对应的存储方式，也就是：

1. 物理结构为连续存储就选择顺序存储
2. 物理结构为分散存储就选择链式存储

可能会有那么一点绕，多理解理解！

# 听说数据结构与算法中的复杂度很难理解？看看这个吧！

## 让人迷惑的复杂度

**小白：** 庆哥啊，这个复杂度到底是个啥啊，我在上大学的时候学这块的时候就很懵😂，不知道是个啥，理解起来很费劲，所以当时也没有好好学习，自己的数据结构与算法这块一直比较薄弱，准备好好再学学数据结构与算法嘞，这一个复杂度都难住我了🤣

**庆哥：** 的确啊，虽然就三个字，但是理解起来也确实有点费劲，我当时学习的时候也是有点理解不了，感觉看了很多解释，总觉得迷迷糊糊的，还是不知道到底是个啥？😂

**小白：** 嗯嗯，是的，我也上网搜了很多的关于复杂度的分析的文章，有些文章觉得越看越迷糊，看着看着就看不下去了，然后我就去看看评论，想着会有人跟我一样觉得看不懂，结果评论都是“写的很好”😂，顿时觉得自己是不是太笨了🤣。

**庆哥：** 哈哈😁，太真实了，那今天咱俩就来好好学习下这个复杂度吧，绝对让你对复杂度有个全新的认识😎

## 一起攻克复杂度吧

**小白：** 嗯嗯，那我得好好学习了，复杂度一直困扰着我，还真的是复杂啊😅，对了，有啥不明白的可是随时提问你的哦，还请庆哥赐教😁

**庆哥：** 小事小事，那咱开始吧，首先我们要知道我们学习啥，那必须是复杂度啊，咋一看，三个字“复杂度”，应该是个名词吧，所以嘞，首先我们得知道，它一定有他本身的概念，那好，我们看看复杂度是怎么定义的，怎么看？必须是百科的解释啊，来，一起看看：

> 在计算机科学中，算法的时间复杂度（Time complexity）是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。例如，如果一个算法对于任何大小为 n （必须比 n0 大）的输入，它至多需要 5n3 + 3n 的时间运行完毕，那么它的渐近时间复杂度是 O(n3)。

看看，明白不？

**小白：** 说实话，看到这个真的有点懵啊😄，时间复杂度？跟复杂度一样吧，什么函数，大O，低阶项，渐进时间，这都是啥跟啥啊😂，是不是涉及数学啊，我数学可一直都不好啊🤣

**庆哥：** 别说你，我刚开始看这个的时候也是一脸茫然啊🙄，也许真的是因为咱俩太笨了😄，怪尴尬😂，不过我觉得这个解释虽然很正确，但是有点官方，对已经只是到啥是时间复杂度的来说很不错，但是对于新手和那些对复杂度概念有疑惑的人来说，真的不算友好，本身就理解的云里雾里，看这个更迷茫了😃

**小白：** 对对对，也许它说的很对，但是这样解释就是觉得好迷茫，不知道到底是个啥😫，庆哥快给我解释解释吧😆

### 复杂度小探
**庆哥：** 嗯嗯，那接下来，我就把我的理解用大白话给你解释一下吧😉，首先嘞，针对你上面的一些疑问咱先来说说，你要知道，咱们这里要探讨的复杂度是数据结构与算法里面的概念，为啥要这样说，中华文字，博大精深，一样的字放在不同的场景里，那含义就不同了，所以咱必须先明确，我们这里讲的 ==复杂度是数据结构与算法中的概念==

好了，知道这个之后，我们还要知道，我们这里说复杂度，更为准确的来说是==时间复杂度==（还有空间复杂度嘞），所以后面咱们不说复杂度了（避免有歧义），就说时间复杂度（因为时间复杂度相对来说比较重要），先跟你说一声，这个时间复杂度是针对于算法的，所以再全面点，我们实际应用中会说成==某个算法的时间复杂度==

**小白：** 是啊，复杂度，哎不对，是时间复杂度😁，就是跟算法有关的，数据结构与算法是块超级难啃的骨头啊😂

**庆哥：** 的确，==数据结构与算法真的很重要==，按时不可否认，真的不容易，很多程序员这块的技能也都不是很强，数据结构与算法这块牛了，那都是大神级别的啊😁，很多小渣渣早就放弃了，根本学不会啊😂

**小白：** 这太扎心了😁，我好难啊🤣

**庆哥：** 虽说数据结构与算法有一定难度，但是还没有到了那种难得学不会的地步，需要你==多花时间，多思考多练习==，很多人第一步都不敢迈出去，当然难了

**小白：** 嗯嗯，确实，很多人听到数据结构与算法，心里不自然的就觉得好难，然后就没有学下去的欲望了，首先就被自己吓到了，我要迈出第一步，跟着庆哥😂

**庆哥：** 哈哈，可以可以，我的这块也是比较薄弱，咱们共同共同学习，那咱接着上面的说，经过上面说的，我们现在知道了，我们要搞定的就是时间复杂度，至于什么大O，低阶项的，咱们一步步来。

### 理解时间复杂度的前提

那时间复杂度到底是个啥呢？我个人觉得啊，要想理解什么是时间复杂度，我们先要知道什么是算法，为啥，因为时间复杂度就是针对算法才有的一个概念，注意啦，我开始慢慢分析什么是时间复杂度了哦😁

**小白：** 嗯嗯，我在注意听着嘞😀

**庆哥：** 好的，千万别走神😎，为啥说理解时间复杂度的前提先要搞明白算法是啥呢？举个例子，比如有人要给你介绍对象，你这人嘞比较在意身高，所以你就问“那货多高啊😂”，别人说差不多一米6左右吧，这个时候你就知道她多高了，这个身高就是衡量一个人的，这个好理解吧，而这个时间复杂度就是用来衡量一个算法的。

你想想，为啥你要问身高，因为你比较在意身高，比如说身高达到一米六就是你的标准，那达到这个标准就是好啊，达不到就是不好，如果人家才一米五，你肯定说，不好，身高不行😂，所以身高也作为你衡量一个人好不好的指标，那对于算法嘞，一个算法也有好不好的说法，那用啥来衡量一个算法的好坏呢？

**小白：** 我知道，时间复杂度😁

**庆哥：** 嗯嗯，说的非常对，我们就可以用时间复杂度来衡量一个算法的好坏，当然，你衡量一个人的好坏，可以有很多指标，身高只是其中之一而已，同理，对于算法的好坏，也有好多指标，时间复杂度也只不过是其中之一罢了，像空间复杂度也可以来衡量一个算法的好坏，不过嘞我们这里主要探讨的是时间复杂度对算法的影响。

**小白：** 庆哥啊，不是要说什么是算法吗，这里好像把什么是时间复杂度给讲讲了吧😀

#### 算法是啥

**庆哥：** 哈哈，别着急，到了这里，你应该知道了，==时间复杂度是用来衡量算法的一个指标==，那啥是算法嘞？

**小白：** 说实在的，我对算法也有点迷迷糊糊的，觉得算法就是一种方法吧😁

**庆哥：** 其实吧，概念性的东西没有个定性答案，所以，按照你的理解没啥问题，所谓算法，当然咱这里也是针对数据结构与算法这块说的，它就是你解决问题采用的一种方式方法而已，我们这学编程的，终究是要落实到代码中的，在代码里来说，不同的算法，也就是你实现的代码不一样，但是达到的目的是相同的，用我们生活中的例子来说，那就是条条大路通罗马啊

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191214174922434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
就像这个图一样，我们从起点到终点，可以选择的路线有很多，但是我们直观来看，图中红色的路线是最近的，其实这里拿到编码中来说，每一条路线都可以说成是一个算法，那这里的好坏就是哪个近哪个算法好啊，这应该没啥难理解的吧。

这里的路线的远近就可以看成是时间复杂度，路线近，我们可以说时间复杂度小，算法就好，路线远，时间复杂度就高，算法相对来说就不好。

那为啥又说衡量一个算法的好坏，时间复杂度只是其中一个指标呢？难道这里的红线路线就是最好的吗？比如我们考虑道路问题，看下面的图，红线虽然近，但是路不好走，黑线虽然远点，但是路好走，综合下来，黑线是最佳路线。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191214175552715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
所以说，时间复杂度并不能作为一个衡量算法的唯一标准，因为还有其他影响算法的因素，只不过，时间复杂度的影响比较大，我们常规讨论算法的好坏的时候经常使用时间复杂度来苹果。

那么，说到这里，你知道了啥是算法和时间复杂度了吧？

**小白：** 嗯嗯，对他们的概念比较清晰了，其实算法这个玩意就是一个怎么做比较好的问题吧😁

**庆哥：** 是啊，所以算法也涉及到思想层面，上升到这个高度就有难度，值得研究了，因为怎么找一个最佳选择，也就是最好的办法是需要费脑筋的，有的人能想到，有的人就是想不到😂

**小白：** 哈哈，是这样啊🤣，这里也知道了时间复杂度是用来衡量算法的一个指标了，也就是清楚概念了，不过不是有什么大O啥的吗？就是它咋用啊😂

### 怎么表示时间复杂度嘞
**庆哥：** 不着急，咱继续，经过上面的讲解，我们大致清楚时间复杂度的概念了，以及它有啥用，那么应该怎样来表示时间复杂度了，我们上面举过身高的例子，那表示身高可以用多少多少cm啊，也就是160cm，那么时间复杂度该怎么表示嘞？

**小白：** 这个我知道，叫什么大O表示法，经常见表示哪个算法的时间复杂度是O(1)啊，或者O(n)之类的。

**庆哥：** 对的，就是用这种方式来表示时间复杂度，那你知道啥是大O表示法吗？

**小白：** 这个就有点迷惑了，只知道这样表示，但是要说啥是大O表示法，就有点懵😂

**庆哥：** 那咱来看关于大O表示法的一个概念解释：

> 若存在函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)
> 的同数量级函数。记作T(n)=O(f(n))，称为O(f(n))，O为算法的渐进时间复杂度，简称为时间复杂度。
> 因为渐进时间复杂度用大写O来表示，所以也被称为大O表示法。

怎么样，看得懂不😁

**小白：**  说实话，懵🤣

**庆哥：** 别说你懵，我也懵😂，没办法，咱们数学差啊，当初学数学的时候，有些概念就是理解不了，感觉说的好绕，那啥是大O标识法嘞，我觉得吧，没必要去纠结它的概念性问题，你只需知道大O标识法的形式就是==O(n)==，啥事大O啊，就是大写字母O啊，然后一个括号，括号里面一个数，这个数可以事已知的，比如说1，其实也就只有1，也可以事未知的，比如n，也可以是2n，3n或者是n的平方（n^2）等等，反正未知的就是跟n相关的函数。

### 大O表示法为啥是n
**小白：** 有个疑问啊，这里为啥是n呢？😅

**庆哥：** 当然，这个n只是表示个未知数，我们之前表示未知数通常是x和y之类的，这里使用n只是个约定俗称的事，也就是习惯成自然😂，大家之前都这样表示，于是干脆就这样吧，使用n来表示，其实吧，这个也跟我们写代码有关，比如我们写一些循环代码，经常出现n，像这样：

```java
public static int test2(int n) {
		if(n<=1) return n;
		
		int first = 0;
		int second = 1;
		for (int i = 1; i < n; i++) {
			second += first;
			first = second - first;
		}
		return second;
	}
```
看到没，这段代码中使用的n，对了，你知道怎么计算时间复杂度的嘛？

**小白：** 就是如何计算一个算法的时间复杂度嘛？我就不会这个😂，看了不少文章，好多都是在介绍啥是时间复杂度，可是就是不告诉我时间复杂度该怎么计算🤣

### 如何计算时间复杂度

**庆哥：** 😂，那咱来说说，因为跟你说了这个怎么计算时间复杂度的之后，你就会更明白为啥是n了，首先，你有没有觉得时间复杂度跟时间有关😁

**小白：** 必须啊，人家就叫时间复杂度，我之前还以为时间复杂度就是多少多少秒之类的😂，结果是O(n)什么的🤣，这是咋算出来的啊

**庆哥：** 你这样理解也正常，那是因为我们对时间这个概念固化了，想着时间那就是时分秒来计算的，这些都是时间单位，是我们熟知的时间单位，但是还有可能时间不是一时分秒来计算，时分秒是确切的，也有可能是抽象的，没什么意思呢？我们弄个代码来看下：

```java
public static int test(int n) {
		
		return n++;
		
	}
```
咋样，这段代码简单吧，就是给定一个值，然后加一返回，我们了解过什么是算法了，这段代码其实就是一个算法，只不过超级简单，它是用来计算一个值加一之后的结果的，那么我们来看怎么算它的时间复杂度，该怎么计算呢？

我们先约定好，在方法体内，每执行一次操作，我们记作1，也就是花费了一个时间单位，你看这里并没有说是1秒还是1分，就说是一个时间单位，我们下面来看这段代码。

在这段代码中，就有一行代码，也就是：

return n++;

它就算做一次操作，所以这里花费的是1个时间单位，也就是1，那它的时间复杂度就是O(1)

**小白：** 为啥啊？😂

**庆哥：** 不着急，我们继续看下面的代码：
```java
public static int test(int n) {
		
		n=+5;
		return n++;
		
	}
```
与上面代码不同的地方是这里多了一行代码，把给定的值加上5，我们来看它的时间复杂度，首先是n=+5这行代码被执行一次，花费了1个时间单位，下面那行代码也是执行一次，也是花费了1个时间单位，那么总的就是花费两个时间单位，所以它的时间复杂度就是O(1)，怎么样，有没有发现点什么啊😂

**小白：** 无论是1个时间单位，还是2个时间单位，他们的时间复杂度始终是O(1)，这是不是意味着，==只要是这些常数个时间单位，时间复杂度始终都是O(1)== 啊😁

**庆哥：** 对，很对，也就是说，只要代码的总执行次数是个常数，那么时间复杂度就是O(1)，我们紧接着来看O(n)的是咋回事，看下面这段代码：

```java
public static int test(int n) {
		int sum = 0;
		
		for (int i=0;i<n;i++) {
			sum=+i;
		}
		
		return sum;
		
	}
```
这里有个for循环，我们看看它的时间复杂度怎么计算，首先第一行代码int sum = 0执行一次，花费1个时间单位，重点在下面的for循环这块，因为这里的n是个不确定的值，经过分析，发现for (int i=0;i<n;i++)这行代码会执行n+1次，也就是会花费n+1个时间单位，循环体内的sum=+1这行代码则会执行n次，也就是会花费n个时间单位，然后最后一行代码会执行一次，就是花费1个时间单位，总的来说就是：
1+n+1+n+1 = 3+2n，也就是总共花费3+2n个时间单位，那么它的时间复杂度就是O(n)。

你看看，觉得这个是规律是啥😎

**小白：** 这里得出的总时间单位就像函数一样，比如f(n)=3+2n，不过我们之前喜欢用x，也就是f(x)=3+2x，只不过这里是n，看这里应该是把常数项去除，然后系数也去除，只保留个n，那么如果是f(n)=3+2n^2的话，时间复杂度是不是就是....

是不是就是O(n^2)啊😀

**庆哥：** 很聪明啊，确实是这样，这里有个比较官方的解释，也就是按照下面的规则去计算时间复杂度

 1. 如果运行时间是常数量级，则用常数1表示 
 2. 只保留时间函数中的最高阶项 
 3. 如果最高阶项存在，则省去最高阶项前面的系数

这个明白吧，举个例子，比如f(n)=3+2n^2+5n，那么3就是常数项，5n就是一阶项。
2n^2就是二阶项，在这里也是最高阶项，那么按照规则时间复杂度是哈？😎

**小白：** 这还是O(n^2)吧😁

**庆哥：** 咋样，现在知道怎么计算时间复杂度了吧，你有没有总结什么规律呢？

## 总结

**小白：** 经过上面那几个例子，我觉得这计算时间复杂度，主要就是看代码中的每一行代码一共执行了多少次，不确定的就是n，然后按照那三条规则来确定最终的时间复杂度，所以重点就是计算每行代码执行了多少次，是不是这样😅

**庆哥：** 是的，就可以这样理解，就像你说的重点就是看每行代码一共执行了多少次，不过有些复杂的代码是不容易算出一共执行多少次的，容易算着算着就迷糊了🤣

**小白：** 哈哈，我也正在思考这个问题呢？咱这里举的例子比较简单，容易计算每行代码执行多少次，但是代码一旦比较绕，比较复杂那就不容易了吧😂

**庆哥：** 确实啊，不过随着我们后续的学习，我们会学习一些经常使用的算法，那么这些算法的时间复杂度会直接给出，我们记着就行了，比如我们看看这个图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191214200346407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
这个就是不同时间复杂度的一个函数图，可以简单理解，越陡的花费时间单位越大，那算法性能也就越差，这个我们只要学过数学，一般都能理解吧😁

**小白：** 嗯嗯，是的，这个还是能够明白的，你说有些常用算法的时间复杂度是给出的，有哪些呢？

**庆哥：** 这个啊，我觉得还是随着我们后续的学习去逐步的了解，比如学到哪个算法，需要分析时间复杂度的时候我们再去说，那样我们记忆的才牢固，不然，这里即使和你说了，也会很快忘掉😂

**小白：** 嗯嗯，有道理😁

**庆哥：** 对了，知道大O表示为啥是n了吧😅

**小白：** 嗯嗯 知道了😀

# 来吧！给你不一样的数组深入讲解！

## 数组小谈😁
**庆哥：** 嗨，小白，知道啥是数组吗？😎
**小白：** 你看你这话说的，数组那还不简单，学计算机的没有不知道数组的吧，我们刚开始接触C语言的时候就有数组啊，现在在学习java，也有数组啊，一般不就这样嘛😁

```
int[] array = new int[10]
```
这就创建了一个长度为10的数组，是不是？😀

**庆哥：** 嗯嗯，你还知道数组的啥啊。比如特性啥的？

**小白：** 这个嘛，数组啊，最经典的不就是可以根据数组下标来读取数据吗？比如上面定义的那个长度为10的数组，可以使用array[1]来获得数组第二个位置的数据。

**庆哥：** 为啥不是第一个的数据，那不是1吗？

**小白：** 这个嘛，那是因为数组下标是从0开始的，所以实际上1就是2的位置，就像这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191213135248983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
**庆哥：** 那数组下标为啥从0开始啊😎

**小白：** 嗯。。。这个？😂不知道

**庆哥：** 在Java中数组其实可以看做是一个对象嘛？😉

**小白：** 纳尼？没有考虑过这个问题啊🤣

**庆哥：** 知道Array和Arrays嘛🤗

**小白：** 不是太清楚😅

**庆哥：** 哈哈，来吧，今天就让你彻底搞懂数组这家伙😎

**小白：** 小板凳已备好😄

## 啥是数组啊😂
### 天马星空看数组😎
**庆哥：** 既然我们要学习数组，那首要的任务就是先要弄懂，啥是数组？你现在清空大脑，不要想着什么数组是数据结构，什么连续内存，什么随机访问，什么不可变的，抛出你之前关于数组的所有认知，从零开始，你想想，数组是个啥？😁

**小白：** 那我要发挥我超强的想象力了哦😂，数组嘛，单从这俩字啊，我想着这玩意应该是个跟棍似的😂，一组一组的嘛，长长的🤣，然后是数据嘛，人家是数组，那应该就是跟数据有关的，组？我们平常会说一组一组的，比如几人一组，那这个数组就是一些数据在一块。。。。我在说啥😅

**庆哥：** 可以啊，你这想象力😂，那我来说下我的理解吧，初看数组这货，我就觉得啊，它在java中应该也是个类，然后我们也可以通过最基本的new来创建一个数组，刚开始就这样感觉得，但是谁知道这家伙完全不按照套路出牌啊😂

**小白：** 你这样一说也真是的，我本来也以为数组可以使用new嘞，有的时候还是有点疑惑的，特别是遇到Array这个类就更迷惑了😂

**庆哥：** 的确，我刚开始也是这样，觉得这个Array不就是数组嘛，然后我还这样试过😂

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191217223712783.png)
哈哈，我当时还迷惑，这是咋回事啊，这不是创建数组嘛🤣

**小白：** 这是咋回事啊，为啥会报错啊😅

**庆哥：** 这个嘛，我们看看Array的源码就知道了
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191217223854461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
看到了吧，它的构造方法是私有的，所以是不能被实例化的，因为我们使用new就是通过构造方法去创建啊，而这里是私有的，所以是不行滴，知道了吧😀

**小白：** 嗯嗯，看来我对这个数组还真的是不了解啊😂，庆哥这次要好好和我说说😄

### java中的数组

**庆哥：** 没问题😎，那我们言归正传，看看java中的数组到底是个啥，在java中啊，我们可以这样理解数组：

> 数组这家伙就是一个数据集合，而且它还是有序的，就是很多数据搁在一块，一个挨着一个，而且每个数据的类型都是相同的

这里简单大白话说了啥是数组，有必要还是画个图，来加深下印象，对了对了，之前画了个图，就用这个

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191213135248983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
好了，现在对于数组，给你文字说了是啥，现在再看个图，这里就相当于有一个数组，这个数组有10个数据，你看他们是不是一个挨着一个，然后每个数据还有一个下标，这个下标就相当于给每个数据进行编号，你想啊，编号有啥好处？

是不是更加容易寻找了，对号入座嘛！所以这里就引出了数组的一个大大的特点：

> 人家支持随机访问啊

**小白：**  这个是不是就是可以使用下标访问数据的特性😀

**庆哥：** 嗯嗯，是的，我们接着来说，我们现在对数组有个大致印象， ，要知道数组最终是用来干嘛的。人家是用来存放数据的，我们还是先来看看数组的的相关代码吧：

```java
int[] a = new int[10];
```
看，这就创建了一个数组，不是我们想的使用new的方式，其实从代码我们就能猜到，这个数组的长度是10，啥意思，数组人家是有长度的。

**小白：** 这个是必须要给它指定一个长度吧
### 数组的声明

**庆哥：** 这个就牵涉到数组的声明了，数组是用来存放数据的，那我们要用它的话就要先创造它吧，之前说了，人家不是使用new，人家是这样的形式

```java
int[] a = new int[10];
```
那么这样可以吗？

```java
int[] a = new int[];
```
有啥区别？是不是少了个10，行吗这样，我们看看

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019121723162944.png)
看到了，不行，为啥不行啊，你想想？

**小白：** 这个嘛，这里的10是在给数组一个指定的长度吧，难道不能默认长度为0吗？

**庆哥：** 这里就要看数组的一些特点了，***对于数组啊，人家是有序数据的集合，在内存中来展示就是人家需要连续的内存空间，还有一个特点那就是你一旦声明就不会再改变了***

**小白：** 嗯嗯，这个我知道，数组一旦确定将是固定不变的，哦哦，我知道了，那这里就必须要求指定长度了，不然相当于没创建数组啊，长度为0没意义啊😂
#### 数组在内存中的分配
**庆哥：** 对的，我们再看这段代码

```java
int[] a = new int[10];
```
是个怎么回事，首先我们知道了，这是要创建数组吧，长度也指定了，是10，对了这里忘了说了，这个数组是个整型数组，类型是int，为啥要说这个嘞，等会再详细说，先来看图

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019121723240734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
啥意思嘞？这些个格格就可以看成是内存，一块块的内存，现在我们创建一个长度为10的整型数组，那就需要十块这样的内存空间。

**小白：** 这里红色的块是啥意思啊？😅

**庆哥：** 红色啊，就代表已经被使用了的内存空间，看出啥问题了没，现在你创建这样的代码
```java
int[] a = new int[10];
```
意思就是你告诉内存，“内存那家伙，给我来十块内存空间，记住必须连续的哦😂”，也就是说，数组申请的内存空间是连续分配的，数组中的数据比较矫情，必须一个挨着一个😂

#### 简单聊聊初始化
**小白：** 嗯嗯，我记得数组的声明不止这一种吧？😉

**庆哥：** 是的，我们之前介绍的这样叫做动态初始化数组，啥意思嘞，就是指定了长度，但是没有给值，我们看这个

```java
 int[] a = new int[10];
  System.out.println(a[2]);
```
输出是0，你可以试下，这10个数据都是0，这是默认初始化的值，我们也可以使用这样静态初始化

```java
int[] b = new int[]{1, 2, 3};
```
啥意思，也就是在创建数组的时候就把值给确定下来，你猜猜这样创建的数组长度是多少？

**小白：**  这个啊，这里没有给定像10那样的数据啊😂，这个应该是。。。3吧😅，后面大括号有三个数

**庆哥：** 我们看下这段代码

```java
int[] b = new int[]{1, 2, 3};

        System.out.println(b.length);
```
这是啥，这是求数组长度的，我们看看输出

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191217234314716.png)
被你说对了，像这样的，它会根据你大括号里的数据创建内存空间，也就是说有几个数就申请几个内存，不多不少申请了就固定了

### 数组变量和数组对象
**庆哥：**  我们上面已经简单介绍完数组了，那你知道什么是数组变量什么是数组对象吗😂

**小白：** 我去，晕菜，这俩双胞胎吧🤣

**庆哥：** 那我来说说，啥是数组变量，看之前的代码

```java
int[] a = new int[10]
```

这个a其实就是一个数组变量，一个数组变量指向一个数组对象，数组变量其实就是一个引用，存放的是内存地址，也就是引用是与内存地址划等号的，内存地址是给计算机看的，而引用是给我们看的（一个我们比较熟悉的符号），而这个a其实是数组的首地址，指向的数组对象其实就是a[0]这个数组变量对应的数组对象。

那数组对象其实就是内存空间中存放的数值了。

#### 数组初始化是对谁初始化
那我们接着这个数组变量和数组对象来讲讲，数组初始化是对谁进行初始化，其实也很简单，知道了什么是数组变量和数组对象之后，我们就应该知道，数组初始化不是对数组变量初始化，而是对数组对象进行初始化。

所谓的对数组对象初始化，无非就是告诉内存，我要创建一个数组，你得给我分配一块连续的内存。

咋样，明白了吧😁

**小白：** ok的😎


## 数组能存储啥😅

**庆哥：** 好了，以上属于数组的基本知识，不多说了，我们接下来再来说说数组的数据存储类型，还记得之前说的吗？数组中的每个元素都是相同的类型，我们上面是int类型的，啥意思嘞？也就是说啊，你创建什么类型的数组就只能存放什么类型的数据。

比如这样就不行

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191217234757294.png)
因为你创建了是个int整型的，所以只能存放整型数据，字符串就不行，想要存放字符串的话那就要创建一个字符串数组

```java
 String[] strings = new String[]{"hello"};
```
### 有个小例外
这里啊，是有个例外的 ，我们看这个：

```java
Object[] objects = new Object[10];
        objects[0] = 1;
        objects[1] = "hello";
```
这个是都可以的，知道为啥不😁

**小白：** 这个啊，知道，Object可是java中所有类的超类啊😂

**庆哥：** 正解，好了，咱来简单总结下：

> Java中的数组是用来存储同一种数据类型的数据结构，一旦初始化完成，在内存中的空间就已经固定了下来

## 数组是个对象？
**庆哥：** 你说数组是不是个对象？😎

**小白：** 数组是对象？不是说数组不能用new的方式创建吗，那应该不是吧，感觉和平常的对象不一样啊😂

**庆哥：** 实话告诉你吧，数组啊，其实是个特殊的对象😎，只不过数组比较特殊，它不同于一般的对象，像一般的对象都有特定的java类，比如我这里创建了一个Person类，然后有这个代码：

```java
 Person person = new Person();
        System.out.println(person.getClass().getName());
```
就是创建一个Person对象，然后得到它的类名，如下

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191218004213339.png)
再来看个

```java
Object object = new Object();
        System.out.println(object.getClass().getName());
```
这个知道吧，它的类名一定是Object，我们看

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191218004310442.png)
是吧，我们再来看数组的，它可以这样获得

```java
//数组是特殊的对象，没有对应的类文件，数组类是在运行时产生的，类名很奇怪
        System.out.println(new int[2].getClass().getName());
```
它这个类是啥嘞

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191218004402345.png)

这是啥玩意😂

**小白：** 我去，这里我是不是只要记住，其实数组也是个特殊的对象就行了吧😂、

**庆哥：** 对的，只需要记住，数组其实也是个对象就行，这可是对数组的深层次理解哦😁，那接下来我们继续说数组的两个让人懵圈的类。

### Array和Arrays
对这俩货熟悉吗😂

**小白：** 很懵圈啊，之前我还想使用Array来创建数组嘞😂

**庆哥：** 哈哈，使用它创建数组是不行的，话说这俩货是干嘛的啊，太容易让人迷惑了，实际上啊，这俩货的存在都是为了让我们更一步的操作数组的，先来个简单的例子，比如我们创建一个数组

```java
 int[] b = new int[]{1, 2, 3};
        System.out.println(Array.get(b, 1));
```
看到没，我们平常是使用b[1]来获取下标为1的元素，使用Array就可以像上面那样获取，也就是说Array给我们提供了可以直接操作数组的一些方法，有如下这些：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191218005145354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
**小白：** 这就是个类似工具类啊，可以方便我们操作数组是吧😁

**庆哥：** 对的，还记得我们之前就说过这个Array吗，它的构造方法是私有的，不能实例化，它的方法也都是静态的，可以直接还用类名来调用，就像上面那样，就是为了我们更加方便的操作数组而存在的。

**小白：** 这样说的话，那这个Arrays是不是类似啊😂

**庆哥：**  是的，Arrays也是个方便我们操作数组的工具类，只是他们提供的功能有所不同，我们使用Arrays可以实现给数组填充数据，也就是赋值，也可以进行排序啊，进行二分查找啊，截取数组啊之类的😂

**小白：** 这个提供的功能还不少嘞😁，使用上是不是和Array类似啊

**庆哥：** 是的，你看，比如说给数组数据进行排序

```java
System.out.println("排序：");

        int[] array1 = new int[]{5, 7, 8, 9, 1, 3, 6};
        Arrays.sort(array1);
```

看它提供的方法

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191218005904199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

也有很多，需要啥我们用啥就行了

咋样，这样一介绍，是不是发现，其实这俩货也没啥难的啊😂、

**小白：** 是啊，原来就是两个打辅助的啊😅

## 数组的特点
**庆哥：** 到了这里，你是不是能 总结下数组的一些简单特点啦😁

**小白：** 嗯嗯，数组啊，连续内存分配，可以随机访问，这次刚刚学到的，数组其实是个对象😎，对了，数组还有下标，是从0开始的。

**庆哥：** 嗯嗯，问题来了，为啥要从0开始，你知道吗？

### 下标索引为啥从0开始

**小白：** 这个还真不知道，平常就记着下标是从0开始的了，至于为啥是从0开始还真不知道嘞😂，为啥啊庆哥。

**庆哥：** 要弄明白这个问题，要看这个图

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191218010642235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
我们已经知道了，数组的创建需要连续的内存空间，比如这里的整型数组，长度为10，那就再内存开辟了相应的内存空间，在内存空间中，每个内存是有相应的地址的，这个是操作系统干的事，当你申请了内存之后，操作系统会为这块内存地址进行编号。

比如这里申请了一个长度为10的整型数组，我们知道int在java中占4个字节，也就是说一个数据占四个字节的内存，也就是上面的一块.

然后每一块都有相应的内存地址编号，比如0对应的这块，编号是1000-1003，占四个字节嘛，我们接下来结合数组的随机访问，比如我们使用array[0]去访问第一个元素，实际指向的就是1000这个内存地址，这个在数组中也叫作首地址，数组变量array就是指向这个首地址。

这个首地址也叫作base_address，记住这个，然后我们如果要访问下标为1的怎么访问嘞，这里有个寻址公式

> array[i] = base_address + i*data_type_size

base_address我们知道是啥了，那data_type_size是啥？其实即使数据类型的字节长度，比如这里的int整型就是4个字节，那data_type_size就是4，我们现在要访问下标为1的数据，代入公式就是：

> array[1] = 1000 + 1*4 = 1004

看下，是不是刚好定位到下标为1的那块内存的位置。

你想想，如果索引从1开始，那寻址供视是不是就变成了

> array[i] = base_address + （i-1）*data_type_size

这就要多一步操作，浪费性能啊😂

咋样明白不😅

**小白：** 嗯嗯，原来是这么回事，终于学会了😎

### 数组的增删改查
**庆哥：** 嗯嗯，那我们再来看看数组的增删改查，也就是对数组进行的一些基本操作，首首先看看数组增加，我们还看着这个图来说

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191218010642235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
如果我们要增加一个元素的话，怎么办？

**小白：** 这分几种情况吧，插在最前面，中间和最后。

**庆哥：** 如果是插在中间呢？发现啥问题没？😎

**小白：** 嗯。。我想想。。数组内存是连续分配的，那要插入一个新的元素，那岂不是要把当前位置的元素以及后面的元素全部后移了，这样才能腾出位置插入当前元素吧😂

**庆哥：** 对的，所以对于数组，不仅是插入，删除也是同样的道理，如果不是尾部操作，都需要进行数组挪动操作。

**小白：** 那这个就费劲了😂

**庆哥：** 是啊，所以数组啊，插入删除效率并不高，最坏的情况，时间复杂度是O(n)，好的情况那就是尾部操作，那就是O(1)了，这个知道吧😀

**小白：** 嗯嗯，知道，那查找效率是不是高啊

**庆哥：** 这里我觉得大家都有个误区，什么嘞，数组如果是使用下标访问，那自然效率高，可是我们平常查找的话是根据数值也不都是下标啊，这样就需要遍历数组找到我们想要的，这个要明白

**小白：** 是啊，你这样一说，我倒知道了

### 数组扩容
**庆哥：** 对了，想一下，如果数组满了咋办😎

**小白：** 这个啊，数组满了，就无法插入新的元素，这样的话就需要对数组扩容，这个扩容，我想想，数组一旦初始化完成，就是固定不变得，这样的话，是不是需要新创建一个数组啊😂

**庆哥：** 对的，数组一旦初始化完成，在内存中的空间就已经固定了下来，即使某个元素被清空，但其所占的空间依然是保留的，因此数组长度是不能被改变的，要想改变数组的空间就必须进行数组扩容。

**小白：** 那这个是不是就需要把原数组的数据全部复制过去啊

**庆哥：** 对的，有如下简单代码
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019121801354639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
**小白：** 哦哦，明白了😎

完！！！

> ps：数组这块怎么说嘞，反正写的有点痛苦😂，现在已经是夜里两点了，先到这吧，如有问题，欢迎大家留言讨论！

# 轻轻松松学会栈和队列（附有顺序栈的实现思路分析）

栈和队列？什么玩意儿😂，别急，今天俺给您说道说道，保准您听了之后，还是不知道啥是栈和队列🤣，得了得了，不皮了，各位看官，您且听好嘞😄

## 对数据结构和算法不熟悉😥

要说到栈和队列，那一定先说两个概念，那就是”数据结构“和”算法“，我知道您可能还不是很了解啥是数据结构和算法😅，或者您知道，但是概念比较模糊，今天俺可不打算给您说它俩，只是给你个建议。

如果你觉得你自己对数据结构和算法的概念比较模糊，怎么整😥，有个办法，那就是找一天时间，专门研究啥是数据结构和算法，可以网上各种搜，也可以请教一些人，保准您花这一天时间，受益无穷😎

那俺就继续说今天的主角栈和队列了😁

## 啥是栈？啥是队列？😌
别急，俺现在就告诉你，我想啊，你在读我这篇文章之前嘞，肯定已经看过不少关于栈和队列的讲解了，或许看的时间比较久了，或许看的不明不白的😂，这都不是事，今天过后，你就不会再忘记啥事栈和队列了😎。

### 关于它俩你要知道的事😀

首先嘞，你要记住，**栈和队列属于数据结构中的线性结构**，也就是线性表，线性？啥玩意，没错，就是你想的那一根根的线，毛线，对，别疑惑，你肯定见过，长长的一根线。

在数据结构中，像数组，链表，栈和队列都属于线性结构，在这些数据结构中，或者说线性结构的一个特点吧，就是人家有个前驱后继的概念，就是一个元素的前后都能再找到一个元素，前面的就叫前驱，后面的就叫后继，看吧，很好理解😀

接着，你还需要知道啥是LIFO和FIFO🙄，咋不知道吗，那可不行，其实简单，就是缩写：

 - LIFO（last in first out：后进先出）--栈这家伙的特点😀
 - FIFO（fist in first out：先进先出）--队列这家伙的特点😁

记住了，**这两个缩写代表了栈和队列这两个数据结构对数据存取的特点**
### 一个生活中的例子看栈😎
啥特点？😫

简单，先说栈这家伙，它是数据结构，就是告诉你，按照它的要求来存取数据的，啥要求，先举个生活中的例子，比如你妈妈让你刷盘子，加入有五个盘子，你肯定事这样干的：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224221102567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
啥意思，就是你最先洗完的那个盘子肯定是放在最低下的，然后其他的挨个往上放，最后洗完的那个盘子肯定是放在最上面的😃

那当我们需要用这些盘子的时候，肯定也是挨个从上面依次拿一个用拿一个用，对吧😁

但是嘞，如果你告诉我，您洗完盘子是这样放的：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224221434143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
我还能说啥，你家地方大呗😂，如果你再告诉我，你是从中间抽着用，我还能说啥？我认输还不行吗🤣

### 栈的数据存取

其实啊，对于栈，它就和这个刷盘子放盘子差不多，每个盘子其实就相当于一个数据，放好的这些盘子的结构就是栈这种数据结构，当然，对于对于盘子我们有放和取两个基本操作，同样的，对于栈来说，无非也就是数据的存取。

对于存就像放盘子一样，最先存进去的数据一定是在最下面的，最后一个存进去的数据肯定是在最上面的，那对于数据取来说，也是从上至下依次取用，我们用个图来表示的话，就是这些的嘞：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224222220370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
咋样，看的懂不😁，为了防止别人说我美工差，我必须得解释解释😂，这里1和2两个大红快你就可以看作是数据，外面的蓝框就可以看作是栈，现在往里面放数据，先把1放进去，看，一下坐到最底下了🤣，后面再来的都在它上面。

如果要对数据进行取用呢？那肯定也是先把2拿走才能拿1，不然你拿不到1啊，它被2给盖着嘞😅

再进一步来说，你可要记住了，这个栈啊，最底部可是封死的，也就是说，对于数据的存取，只允许你在一段进行操作，看上面那个图，被封死的那个口我们叫它栈底，允许你进行数据操作的那一个口，也就是开着的我们称为栈顶，咋样，这个还是很好理解的😏

所以，你发现没，对于栈这个数据结构来说啊，它对数据的存取是有一定要求的，也就是只让你在一段进行数据操作，也就是你只能操作栈顶的元素，另外，除了栈顶，其他元素你是不可见的，因为都盖住了😅，你看图是不是。

好了，到这里你知道了关于栈的两个术语，也就是栈底和栈顶，咋样，有没有成就感😂

知道了这么两个玩意儿，那就很容易理解啥是出栈啥是入栈了吧，入栈不就是把数据存进来，对了，存进来的这个数据就成了栈顶元素喽，那对于出栈，可不就是把数据拿走吗？

再看个图就是这样的：😃

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224223314922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
咋一看，我画的图还不错啊😂

最后啊，为了让你更清楚了理解栈这个结构和它对数据存取的特点，我再给你说个东西，保准你恍然大悟，醍醐灌顶啊，啥嘞，不知道栈是啥样的是吧，打过羽毛球不，那知道装羽毛球的那个盒子吧，你拿羽毛球是不是开个口，然后挨个拿，你能直接拿到中间的吗？必须不啊，如果你说，我可以开俩口，可以拿到最后一个，我说大哥，咱能不抬杠不😂

所以啊，栈嘞，就是先放进去的要最后才能拿，对数据来说，就是后进先出（LIFO）.
### 一个生活中的例子看队列
现在你知道啥是栈了，那队列嘞😲，其实这俩货也差不多，都是对数据的存取有着比较特殊的要求，比如栈，人家就允许你在一段操作数据，也就是栈顶，你只能在栈顶玩耍，那么队列嘞。

首先，你看到队列俩字想到啥，排队？一群小学生排队？有相似之处，不过还是有差距，人家小学生排队，说不定哪个小男孩看上哪个小女孩就去插队了，就是学生可以自己随意走动，但是相比较队列这个数据结构就有点不同了😮

队列啊，人家对数据的要求也是有严格要求的，啥嘞，就是对于数据的存储，要在一端进另一端出，你想想栈那孩子，是不是只能在一端也就是栈顶玩耍，数据的存取都从栈顶这一个口，但是队列人家两端都开口，不过要求你从这端进必须那端出。

想想生活中汽车过涵洞，假如这个涵洞的宽度只能够一个汽车顺利通行，那汽车们是不是就要排好队，挨个进挨个出了，你说你想插队，那是不可能滴，看上哪个女司机，你也不能插过去啊😂

看图就是这样的：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224225323194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
这个画的确实有点抽象了哈😂，凑合着看吧😅

### 队列的数据存取

看看这些红红的方块车😂，要想顺利通过这个涵洞，是不是要按照顺序一个个来，最先开进去的也是最先开出来，这其实就是队列对数据存取的特点啊，先进先出（FIFO）😁

下面咱看看队列的示意图吧：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224230059108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

这里的入队，出队，队尾和队头应该都好理解啊，看着图一目了然啊，这就是队列了，这么一看，是不是感觉队列也好简单啊，其实关于队列的概念，只要好好看看，理解理解，还真的没啥难的😀

要记住的就是队列这家伙，要求的是一端进一端出，也就是要满足先进先出的原则。

> 其实关于队列还有什么循环队列和优先队列之类的，不要着急，路要一步步走，步子跨大了容易😂，以后肯定会讲到。

## 栈和队列难不难？😂
其实吧，关于数据结构这块啊，如果你仔细去学的话就会发现，关于数据结构的一些基本结构没啥难的，那么难的地方在哪呢？

那肯定是把这些数据结构用代码给实现出来啊😂，咋样，这一步对很多人来说是不是有难度，这个也是我们学习数据结构与算法必须跨过的坎，不过不用着急，我们一步步来，先把最基本的东西搞懂了，后面再去几种搞代码。

不过这次我还是简单说一些，因为其中牵涉的有些知识点还是很有必要现在就知道的。

### 怎么实现栈和队列
那你想想，像栈和队列这俩货，我们可以怎么实现他们呢？可以用什么来实现呢？😀

记住这句话：

> 基本上所有的数据结构都可以使用数组和链表来实现😁

所以啊，无论是对栈还是对队列来说，我们都可以使用数组和链表来实现他们，当然，使用数组和链表实现一定是有所不同的，因为本身数组和链表就是两个不同的数据结构。

记住了，用数组实现的栈叫做顺序栈，用链表实现的栈叫做链式栈，那队列嘞，同样的道理，那至于为啥叫顺序栈和链式栈，这个也好理解吧，这都是根据数组和链表各自的特点啊😀

接下来，我们就以数组来实现栈，从而说一些比较重要的知识点😎

### 数组实现顺序栈(思路分析)
那使用数组该怎么来实现一个栈呢？这次我重点是梳理思路，不会给出一些完整的代码的，因为我觉得只有你把思路理清了，你才知道使用数组实现栈的时候有些步骤为啥要那样做😉

#### 需要些啥😮
那好，现在根据我们上面讲的栈的相关知识，我们来看，对于一个栈来说，它的基本操作无非就是入栈和出栈，我们列出来：

 1. 入栈
 2. 出栈

既然实现一个栈，我们用数组，那我们是不是要创建一个数组，用来底层存储栈的数据啊，好还需要一个数组：

 1. 入栈
 2. 出栈
 3. 数组

好了，大致上我们直观感觉到的就是这么多了吧，接下来我画个图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224232736370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
先看这么一个图😎，这跟之前画的那个图是一样的，只不过这个躺这了😂，现在我们要用数组实现一个栈，其实也就是按照栈的要求去往数组中存取数据。

#### 数组该咋弄😂

栈啥要求？基本的就是后进先出，比如这里已经进去的四个元素，1是最先进去的，就放入栈底了，4在这里看是最后一个进的就属于栈顶元素了，现在，我们想想，代码需要写啥，首先肯定需要一个数组：

```java
  private int[] array;//用数组实现，只能存储整型数据
```
好，现在我们定义了一个数组，那你想想，这个数组我们该定多长呢？所以这是个问题吧，我们需要给个长度：

```java
private final static int size = 10;
```
比如默认给个10，这个时候我们已经可以创建一个长度为10的整型数组了，再想，我们现在要实现的是栈，底层也就是往数组存取数据，比如往数组中放一个元素，栈中的元素是不是就多了一个数据，这里的size是表示数组的长度，那怎么表示栈中的元素呢？

想一想，本身栈是空的吧，也就是一开始还没有数据入栈的时候，栈是空的，然后入栈数据就多了一个，出栈数据就减少了一个，想到了吗😁，这里是不是可以搞个计数，比如定一个整型变量来表示栈中的数据，入栈就加一，出栈就减一，那好我们定义一个：

```java
int count;
```
你又要想了，那空栈怎么表示呢？你说，空栈不就是数据元素是0个嘛，可以，我们可以默认count一开始为0，表示是空栈。

#### 栈顶指针很关键😎

接着我们再看栈的一个特点，就是只能在栈顶玩耍，也就是说啊，我们操作栈实际上操作的就是栈顶的那个元素，那我们是不是可以弄个啥，专门来代表这个栈顶元素呢？

这里一般的实现思路是搞个栈顶指针，实时指向栈顶，一般叫做top，栈顶可不就是top嘛，人家是这样的：

```java
 private int top; //栈顶指针
```
你看到这跟之前那个count是不是一样啊，这里可有点不一样，哪里不一样呢？count代表的是栈的元素多少，这个top可代表一个栈顶指针啊，其实这个指针也并不是真正意义上的指针，count我们把它默认为0代表空栈，那这个top怎么来代表空栈呢？还是0？显然不可能。

那是多少😅，考虑到要实时指向栈顶，向下，比如我们入栈第一个元素，也就是往数组放入第一个元素，那位置肯定是a[0]啊，这个时候a[0]就代表栈顶元素啊， 再入栈一个就放在了a[1]的位置上了，那么这个top怎么指向呢？

继续思考，top要想实时指向，肯定要随着入栈和出栈做移动，怎么表示这个移动呢？最简单的不就是做加一减一的操作吗😀，那默认值是多少嘞，想下，是不是搞成-1比较靠谱。

为啥事-1，此时-1代表空栈，入栈一个元素top加上一变成了0，此时的元素不久恰好放在了a[0]的位置上了嘛，咋样，懂了吧。

这样一来，top的值就和栈顶元素在数组中的位置时一样的，可不就是实时指向嘛，看图，首先时空栈
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224235439244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
然后入栈一个元素，top+1

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019122423560077.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
咋样，知道了吧，于是乎我们创建一个栈就可以通过构造函数这样来：

```java
//调用无参构造函数创建一个默认长度为10的数组
    public StackArray(){
        a = new int[size];
        top = -1; //栈空的时候
    }
```
#### 入栈原来是这么回事😊

那我们再想，怎么表示栈顶元素呢？看图，很简单的，是不是就是a[top]，那么入栈的话，是不是top加一，然后通过a[top]指向这个栈顶元素。

> 这里一定要记住的就是top的值和栈顶元素在数组中存的位置是一样的

所以入栈其实也就是top加一之后拿到这个元素应该在的位置，然后把数据放到数组中，这其实就是栈的入栈操作啊，代码大致时这样：

```java
//入栈，往数组中存放元素
    public void push(int element){
        //判断栈是否已满
        if(top == size-1){
            throw new StackOverflowError();
        }
        else {
            a[++top] = element;
        }
    }
```

#### 出栈也不过如此😂

那再想想出栈嘞，出栈时怎么一回事嘞，我们再看个图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225000354244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
比如这里入栈了两个元素，如果我们要出栈，那就是把2给出栈，那么自然1又变成了栈顶元素，所以top应该指向它，做法就是指向2的top减一就行了。

想想是不是😀，也就是变成现在这个样子了

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225000642516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
所以出栈啊，就是使用top减一来模拟的。

这里就有个疑问了，这里虽然top减一，代表此时栈顶元素时1，那么这个2是不是还在啊😂

对了，这里实际上2依然还是在数组上的，只不过暴露给外界知道的是此时栈顶元素是1，理想状态2已经被干掉了，然后你再想，如果再次入栈，是不是top又指向2的位置，然后来个新值给他覆盖掉了，明白了吧😊

所以出栈的代码大致如下：

```java
  //出栈
    public int pop(){
        //判断栈是否为空栈
        if(top == -1){
            throw new EmptyStackException();
        }
        return a[top--];
    }
```

> 注意a[top--]是先计算a[top]然后top再自减

#### 精华总结🥰

以上就是关于使用数组创建栈的一些实现思路了，这里有一些注意点：

 1. 使用一个top来作为栈顶指针实时指向栈顶元素
 2. top的值和栈顶元素在数组的位置是相等的
 3. top的值和栈的元素数量关系是top = count-1

好了，以上大致就是本文的全部内容了，关于栈的链式实现以及队列的实现，以后我们搞代码的时候单独说。今天就先到这，如果觉得本文不错，可以转发分享或者点赞支持一下哦😘

# 链表是个啥？怼起来

**小白：** 庆哥庆哥，链表是什么啊？😂

**庆哥：** 呦西，那么爱学习啊，那咱今天就来把链表怼一怼吧，争取以后再也不学链表啦😎

**小白：** 为啥以后再也不学啦，难道链表没什么用吗？😁

**庆哥：** 那必须不啊，链表不仅有用而且很有用，必须好好掌握，为啥以后不再学了呢？因为经过这次的学习，你就再也忘不掉啦😎

**小白：** 那庆哥，我可先说好了，我之前可是对链表一窍不通啊😂

**庆哥：** 那没事，谁不学那都是不会滴，学了不就毁了嘛，接下来咱就一起学习链表，攻克这个知识点，记住，有什么不懂得要赶紧问哦。

**小白：** 好呀，我的第一个问题来啦，什么是链表啊🤣

**庆哥：** 首先就从“链表”二字来看，你觉得是个啥？想一想。链表？链子？表？😀，有想法没😂，有的时候对于名字啊，为了便于大众的理解，名字一般就简单的体现了它是个啥，所以链表是俩字，一个链一个表，那什么是链什么是表呢？

## 1️⃣啥是链表？拆开来看😂

**小白：** 这个啊，我想想，链是不是就是我们常见的链子啊😂

**庆哥：** 是啊，就是这样的😂。，大铁链子，不不，大金链子

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2l0aHVhbmdxaW5nL215aW1nL21hc3Rlci9pbWcvdHJ1ZS5qZmlm?x-oss-process=image/format,png)

你看，就是这个。怎么样，看到这个大金链子，有没有觉得自己对于“链”这个词有点意思了，知道它大概是个什么玩意了吧。
**小白：** 嗯嗯，是的，链子嘛，就像这个大金链子一样，一环扣一环的😁，那啥是表呢？我记得之前常说这个表啊，什么数据表，对，还有之前说的哈希表，这个表是个啥啊？
**庆哥：** 的确，我们之前一直都在说什么这表那表的，但是啥是表呢？难道是我们戴的那种手表吗？钟表？当然不是啦🤣，咱们这说的表一般是指：

>  按照一定顺序排列的元素集合，那就是表

啥意思呢？也就是说啊，咱们这里的表指的也是一些数据集合，啥是数据集合嘞，就可以理解成一堆数据😂，只不过这数据人家有一定的顺序。

**小白：** 顺序？是不是那种按照12345这样排序啊😁

**庆哥：** 这里的排序啊，是这样的，它嘞，有一个前驱后继的概念，啥意思咧，看图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208103927969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
其实也好明白，说白了，在这个表中存储的也就是数据，这些数据是按照顺序排列的，这里的顺序的理解是这样的，就是表中的每个元素就是一个数据吧，这些个数据，它的前面也有数据，后面也有数据，前面的数据就叫做这个数据的前驱，那后面的嘞，自然就是后继了。

**小白：** 那每个数据都是这样的吗😃

**庆哥：** 那可不一定啊，你想想最前面的后最后面的那个，是不是最前面的只有后继，最后面的只有前驱呢？你可以想想那种排队的，最前面那货和最后面那货😁

**小白：** 嗯嗯，这下对表这个概念有点理解了，说白了，不就是数据集合嘛😂

**庆哥：** 可以的，就可以这么简单的理解，清楚这个概念之后，再看“链表”，知道是个啥了吗？有没有觉得概念清晰一点了。

**小白：** 嗯嗯，经过前面的大铁链子还有这个表的理解，现在对链表是个啥，明白了许多，我现在的理解就是，链表就跟个大铁链子似的，不过每个节点不是大铁环子😂，而是一个数据🤣

**庆哥：** 哈哈，可以的，这样理解也是可以的，不过你觉得这个每个节点的数据是咋样的呢？
##  2️⃣链表长啥样？
**小白：** 经过上面的讲解，我现在对链表的理解，它就是这样的：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208105842266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
链表嘛，就跟大铁链子似的，一个扣着一个，每一环其实都是数据。

**庆哥：** 可以的，这样理解不错，不过还不是太准确，虽然说链表跟大铁链子似的，毕竟人家不是大铁链子啊😂，不是真的像大铁链子那样，一环扣着一环的，大铁链子是物理上存在的，可以互相的一环扣着一环，但是像链表，人家是个数据结构，不是那么可以看得见摸得着的，所以，人家的链接可不是像大铁链子那样，那么，你想想，对于链表而言，它的每个数据是怎样链接的呢？

**小白：** 这个啊，让我想想😒，数据之间互相链接起来？咋链呢？不能手牵手吧🤣，哦哦，我想起来了，可以用指针啊，就是用个指针指向下一个数据，这样也行吧？就像这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208110746871.png)
行吗？😃

**庆哥：** 必须可以啊，实际上，链表中就是依靠指针互相链接的，那么你对指针了解的多少呢？

**小白：** 指针啊，掌握的不是太好，这个是在学习C语言中学的，在java中没有指针吧，好像java中的引用和指针类似。

**庆哥：** 是的，指针可以说是c语言中的精髓啊，比较难理解，而且容易出错，所以java语言在设计的时候号称吸收C语言的特定，摒弃其难理解且容易出错的指针，实际上，在java中的引用就和指针类似，在学习链表的过程中，理解指针的概念很重要，这将有助于对链表的理解和掌握。

**小白：** 嗯嗯，我也知道指针的重要性，但是，对于指针的话，我觉得理解起来好费劲啊，也不知道是不是自己没有找到好的方法去理解，反正对于指针的概念总觉得模模糊糊的🤣。

**庆哥：** 指针确实是个值得研究的东西，这次我也不能花大篇幅去给你说指针，这里咱们针对这个链表去把这里的指针给弄清楚就行了，我们先来看个图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019120813360914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

这个图应该是比较清楚的吧，这个图中链表才是链表的真是样子，不是这样哦😁

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208105842266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
**小白：** 嗯嗯，单独看你花的这个链表和我这个有点像啊

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208110746871.png)
### 详细讲解链表节点
**庆哥：** 确实如此，你画的这个基本上可以说就是一个链表的样子，但是我觉得这里有个很重要的点必须画出来，那就是链表中的每个节点不单单是一个数据，而是基本的包括两个部分（这里暂时说的是单链表），一部分是实际存储的数据，一部分则是next指针，也就是指向下一个数据节点的指针，所以，以下这个图对理解链表比较重要：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208134051553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
就是这个，也就是说在链表中啊，每个节点包含两部分，就像上图那样，一个是data，一个next，data就相当于实际存储的数据值，而next指针的，也是存储的一个数值，这个数值是下一个数据的内存地址。

**小白：** 这个？有点不明白啊，data是保存的实际的数据值这个知道，不过对于这个next还是有点模糊啊。

**庆哥：** 嗯嗯，那好，我们现在来看这个图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019120813454517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
首先左边的这个数据1知道是个啥吧，它就相当于一个链表中的一个节点，下面是一个完整的链表：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208134704961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
很容易看出来，这样的一个节点有两部分组成，一个是data，一个next，那么，data是啥呢？next又是啥呢？首先你对这个图了解吗？

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019120813481837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
**小白：** 这是个数据在内存中的存储吧，有点模糊。😂

**庆哥：** 那我给你大白话的讲一下，首先嘞，这里有个内存，内存是啥，可以供我们存储数据吧，那好，我们现在要存储数据了，比如我们要存储3个数据，现在就要向内存申请三块地方供我们存储，于是内存给我们划分了三块地方，我们分别存上三个数据，就如上图中那样，分别存储数据123，这个知道吧？

**小白：** 嗯嗯，你这说的很清楚，明白了。😀

**庆哥：** 那好，咱们继续，现在你既然给内存要了三块地址，那么内存总得给这三块地址编个号吧，毕竟这三块地方被使用了，里面还存放着数据，假如有人要要这些数据的话，我好告诉它去哪里找这些数据啊，于是乎，这三块地方被编上号了，就是图中的那样，这个明白吧😏

**小白：** 嗯嗯，原来是这么回事啊，经过你这么一讲，我倒是明白的很呐😂

**庆哥：** 嗯嗯，这里还需要进一步说明，我们之前不是说了吗，链表中的一个数据节点包含两个部分，一个data和一个next，比如我们要在链表中存储一个数值5，那么它就是这样的：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208140332369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
看到了没，在申请的三块地方，第一块地方被命名成0x0000，这块内存空间存放的就是数据1，数据1嘞，其实分为两部分，一部分存储数值5，一部分则存储next指针，也就是0x0001，这不就是第二块内存空间的地址嘛，我们根据数据1中存储的next指针也即是0x0001就可以找到第二块内存空间，从而找到数据2啊。

咋样，明白不？😅

### 链表像数组？
**小白：** 这块经你这么说，确实明白了很多，不过这里我怎么感觉链表有点像数组啊，内存空间是连续分布的吗？你看这0x0001,0x0002😂

**庆哥:** 确实，你这个问题问的很好，我们知道数组是按照顺序排列的，在内存中申请空间也是一整块的，连续的，链表也是这样吗？答案当然是不，其实，链表它的常态是这样的：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208141622117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
你看，跟上面的那样有什么区别吗？

**小白：** 嗯嗯，不一样的就是内存中申请的内存空间不是连续的了，这个比较散，咦，不对啊，在上面那个连续的地方，数据1的next指针存放的是0x0001，指向的就是数据2，那么现在这样不对吧🤣

**庆哥：** 可以啊，看的很仔细嘛，确实，这里的数据1的next指针存储的空间地址就不是0x0001了，因为要指向数据2，那么数据1的next就应该存放的是数据2的内存地址，也就是0x0008，就是这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208142034522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
咋样，这下清楚了吧？

### 链表的特点有啥？
**小白：** 嗯嗯，明白了，那链表和数组有啥区别呢？也就是说，我想知道的是链表有啥特点啊？😂

**庆哥：** 想知道链表和数组的区别是吧，那你知道数组有啥特点不？

**小白：** 数组啊，它比较明显的特点不就是支持随机读取吗，也就是读取的效率比较高，因为可以使用下标来直接访问，而且数组的内存空间都是连续的，大概是这个样子的：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208154923691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
这里是一片内存空间，红色的代表一个数组的空间地址分布，它都是连续的，占用一整块的内存空间。

**庆哥：** 可以啊，数组基本就是这样的，不过关于数组后面我们单独会进行探讨，这里这样的理解已经可以了，现在我们知道数组是这样的，那链表的，它是这样的：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208160130163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
看见了吧，链表的分布式没有顺序的，非连续的，也就是随心所欲，想在哪在哪，那怎么找到下一个的，就是靠指针连接的。那根据这个图，想一下，链表有啥特点嘞😲

**小白：** 想想啊，对于数组，内存分布式连续分布的，支持下标随机读取，如果要插入删除的话，则需要进行数据移动啥的，所以对于数组吧，读取效率高，但是插入删除操作就不咋滴了，再看这个链表，因为内存分布不连续，想在哪就在哪，只要有空地就可以用，那按照这样说，链表的插入删除效率比较高啊😂

**庆哥：** 那是为啥嘞？

**小白：** 我是这样想的，就比如链表的插入吧，就是新增加一个元素呗，就像这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208160830467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
就像这样，中间那个深红色的是新增加的，那么只需要把指针指向更改一下就ok啦😂

**庆哥：** 哈哈，说的很正确啊，666啊，那链表的读取嘞？😁

**小白：** 读取吗？这个？我想想啊，数组可以支持下标直接读取，那效率比较高，这个链表没啥下标，那么只能是找到一个数据之后只能根据当前数据保存的下一个数据的指针找到下一个数据，其他的也是依次类推吧😁

**庆哥：** 嗯嗯，说的很对的😎，所以说啊，对于链表来说，插入删除这类操作比较快速，但是读取的话就不像数组那样，只能一个一个的找啦😂 

**小白：** 嗯嗯，那这就是我们所说的链表了吗？😁

### 还有双向链表嘞
**庆哥：** 对，你这一问，我倒是要好好说说的了，上面我们讨论的这种链表，就是这样的：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208162549918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
这个实际上叫做单链表，除了这个还有双向链表，那双向链表是啥嘞，你自己想猜一下，这个双向链表是个啥？😃

**小白：** 单向链表，双向链表？我想想，哦哦，是不是这样啊，单向链表我们上面的图显示的是那些箭头都朝一个方向，那上双向链表是不是还有相反方向的箭头呢？😊
就像这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208162856794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
是不是这样啊？😂

**庆哥：** 嗯嗯，理解的很对，那你知道这箭头都是啥嘛？😂

**小白：** 这个不就是代表指针指向嘛😁

**庆哥：** 是的啊，那么你看我们之前的图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208162549918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
这里我们之前说的，next指针存放的是下一个数据的内存空间的地址，通过这个next可以找到下一个数据，那么你再看你画的这个：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208162856794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
有没有发现问题，这样的双箭头，next到底存的啥呢？😂存放的下一个数据的内存空间地址嘛?那好，那由data指向next的又是咋回事呢？难道data中也存放空间地址嘛？不对吧，人家data存放的是实际数据啊。

**小白：** 你这样一说，好像是的啊😂，迷糊了🤣

**庆哥：** 它其实是这样的：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208164234315.png)
看到了不，这里多了一个prev，这是啥呢？想一想

**小白：** 你这样一画，我就明白很多了，这个next代表指向后面的指针，那么这个prev是不是就是指向前面的指针啊😁

**庆哥：** 嗯嗯，是的，next和prev都是用来存放空间地址的，next就像我们之前说的存放的是后一个数据的内存空间地址，而prev就是存放的前一个数据的内存空间地址。

**小白：** 哦哦，这也就是双向链表啊，那么，这两端的null是咋回事啊😯

**庆哥：** 这个啊，也简单啊，你想啊，最前的那个数据，他前面是不是没有数据了，那prev不就是指向null了，那么最后的那个数据同理啊😃

**小白：** 吆西，懂了懂了😁

**庆哥：** 那么你知道啥是循环链表嘛？😎

**小白：** 啥，还有循环链表🤣，我想想啊，循环的话是不是头尾相连啊，就像这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208165121605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
是不是？😃

**庆哥：** 可以的，完全正确。

**小白：** 感觉今天学到好多知识啊，那么链表就这些内容了吗？
## 3️⃣链表的基本操作
### 查找操作

**庆哥：** 为了加深理解，我们再来看看链表的一些基本操作，首先嘞，我们来看看链表的查找操作，要知道这里的查找，其实就是查找某个节点，这里我们还拿单向链表来说吧，看下面的这个链表：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208165806935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
假如现在我们要查找数据2这个节点，怎么查找呢，首先我们得知道，链表可不像数组那样，可以通过下标来直接访问，对于链表来说，如果要查找数据的话，首先要从头结点开始查找，这里头结点就是数据1

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208183735223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
然后判断是不是自己需要的数据，如果不是根据next找到下一个节点：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208183911222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
以此来进行链表数据的查找，知道找到我们需要的额数据。

### 更新数据
那么对链表的更新操作呢？你觉得链表的更新是怎样的？

**小白：** 更新数据啊，我觉得吧，首先应该也是找到需要更新的那个数据吧，找到之后再把该数据进行更换，更换的话应该比较简单吧，直接将该节点数据换一下就行吧，就像这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208184232778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
比如要更改数据2，找到这个节点之后直接把新的数据替换掉旧的就可以。是不是这样？😁

**庆哥：** 可以啊，理解的很正确啊，对于链表的更新操作就是这样，下面我们再来看链表的插入操作，关于链表的插入操作，我们需要好好的学习下，因为链表的优势就是在这里，插入删除的效率比较高，简单点就是把指针的指向改变一下，下面我们来集中的看下链表的插入操作。

### 插入数据

这里需要知道的是链表的插入操作分为三种情况，你想一下有哪三种情况😏

**小白：** 既然是链表的插入操作，我先来看看链表的这个图吧

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208184859243.png)
按照这个图来说的话，插入的话，那应该就是插入的位置不同，按照插入的位置，那应该是插入在第一个位置，插入到中间或者是插入到最后一个位置😂

**庆哥：** 分析的很对啊😉，其实就是分为

 1. 头部插入
 2. 中间插入
 3. 尾部插入

也就是这三种插入情况，下面我们来逐一看一下，首先是这个头部插入，顾名思义，头部插入嘛，也就是你新增加的那个数据是排在第一位的，像这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208190406760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
看图感觉也是很简单的，这里要注意的就是要把新插入的这个数据的next指针指向原来的头结点，自然的，现在新插入的这个数据就变成了新的头结点了。

下面再来看中间插入，这个中间插入相对来说较为复杂一点，怎么回事呢？我们来看：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208191020165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
看到了吧，对于中间插入，也是指针的更换，这里是要在数据2和3之间插入一个新的节点，那么数据2的next指针就不再指向数据3了，而是指向新插入的这个数据，而新插入的这个数据的next指针则指向原有的数据3，这就完成了数据节点的插入操作。

紧接着我们再来看最后的一个插入，也就是尾部插入了，尾部插入应该是最简单的一个，看图就知道了
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208191507240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
直接将最后一个数据节点的next指针指向新加入的数据节点即可。

怎么样，这下对链表的插入有所了解了吧😎

### 删除数据

**小白：** 嗯嗯，这下感觉明白了很多啊，也更加清晰了对这些概念，是不是就剩下最后一个删除操作啦，我觉得这个删除操作和插入操作很类似啊，我来说一下，你看看对不对。

首先对于删除操作应该也是分为三种情况

 1. 头部删除
 2. 中间删除
 3. 尾部删除

对于这个头部删除的话，其实也就是把第一个头结点删除掉，然后第二个节点现在成了头结点，而中间删除的话是这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208192403124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
比如这里要删除数据3，那么就需要将数据2的next指针指向数据4，而不再是数据3了，那么对于尾部删除的话，也比较简单，就是删除掉最后一个数据节点，倒数第二个的数据结点成了最后一个，自然它的next指针就指向null了。

我理解的对吗？😂

## 4️⃣总结

**庆哥：** 厉害厉害，理解的非常对，对于链表的删除操作就是这样的，好了到了这里关于链表咱们大致就说的差不多了，接下来稍微总结一下。

其实对于链表吧，它包含的知识点还有很多，如果要深入研究的话，那要花费的时间还有很多，所以，学习链表还是急不得，要一步步来，慢慢去学习，而且对于链表的学习，我们最后是要回手写链表的，关于这些内容，咱们以后会慢慢去探讨。

对于链表的理解，我个人觉得很重要的一点就是下面这个图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191208193106106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
也就是说，链表中的每个节点其实是包含两部分，一个是data，一个是next，当然咱这里是针对单链表来说的，这个data好理解，就是存储实际数据的，而这个next呢？它也是存放数据的，只不过存放的是一个内存空间的地址，这个内存空间地址值就是下一个结点的内存空间地址，链表就是这样互相链接起来的。

所以，链表不像数组那样，需要一个连续的内存地址，只要还有内存空间还有，那么链表就可以一直存储，有种见缝插针的感觉，反正结点之间是依靠指针链接的。

而对于链表的基本操作，说简单点，就是指针的指向发生了改变，当然，很多事情都是说着容易做着难，很多人虽然对链表清楚了，但是真的让上手去写一个链表就直接懵逼了😂，这是大家都会遇到的问题，别担心，后续我们再继续一起学习。

慢慢来，不着急，这次就先到这了，回见！😁



# Java代码实战：通过手写一个单链表，告诉你学习编程的方法和捷径！

> 读者朋友们，你们现在可以手写一个单链表吗？😄

截止到目前，我还经常收到一些读者的微信，他们向我抱怨道“**为什么我看视频或者看书都能够看懂，就是写不出来代码呢？**”

哈哈，这是不是就是我们一直说的“**一看就会，一做就错**”呢？别说你们，我相信每个初学编程的人都会遇到这样的问题，看书觉得自己看明白了，知道咋回事了，可是一到自己写代码，要么无从下手，要么bug百出，真的很打击信心啊。

对于编程的学习，很多人也会问我有没有什么捷径，我通常回答说“**多看多练**”，但是实际情况是很多人都是看的多，练的少，这其实是导致很多人，**一看就懂，一做就错，时间长了就忘**的罪魁祸首之一（还有很多自身因素），尤其代码这块，更加要多敲！

今天，我就以单链表为例来聊聊写代码这些事吧，我会一步步带大家写出一个简易的单链表，并且中间会不断的给大家讲解如何进行代码实战，这其中的一些思考方法也是很重要的。

## 知己知彼，方能百战不殆
首先就是关于写代码的第一步，那就是你得理解你要写什么代码，比如我们今天要用java去实现一个单链表，那么，你必须得知道啥是链表吧，这是前提啊，如果你连链表都不知道是个什么玩意，那你能写出个什么玩意呢？😂

而且，你不仅要了解，还要深入的了解，这样写起来相应的代码才会得心应手，就拿链表来说，也许你现在不知道啥是链表，但是嘞，你花个十来分钟，随便找一篇文章看看，也许对于链表就能知道个大概，但是即使如此，让你实现一个单链表，你很大可能还是写不出来。

简单的了解并不能让你轻松的写出代码来，你还需要对其中的一些关键性知识做深入理解，比如链表里面的指针，其实在java中没有指针这一说，取而代之的可以说是引用，但是写链表代码的时候我们一般都会说指针，什么next指针，所以啊，对于手写单链表，你不仅要理解啥是链表，更要理解其中指针的含义。

对于链表，我之前特意写过一篇文章，详细的聊了聊链表，建议对链表不熟悉的去看看再回过来看今天的实战部分：[链表不会？看这个立马就懂！](https://blog.csdn.net/sinat_33921105/article/details/103434447)

## 心急吃不了热豆腐
对于手写单链表，在了解了链表相关的知识之后，我们就要分析一个单链表该如何实现了，我们初次在进行这样的操作的时候不要渴望自己一次就能写出完代码来，我觉得那是不可能的，刚开始我们可以写简单点，代码可以写的不那么优雅，不那么高效，但是要实现最起码的功能，然后把这些基本的简单的理解透了，再去不断迭代我们的代码。

**要知道，好文章都是修改出来的，代码也是一样！**

所以这次手写单链表，我们就实现一些简单的功能，比如最常用的增加一个新的节点，然后还可以删除一个节点，当然我们还可以看看这个链表保存的数据，也就是打印链表。

链表是个重要的知识点，我们要一步步的去攻克它，不要想着一口吃个胖子，一下子把链表相关的代码都烂熟于心。

## 这个节点该怎么定义
我想你已经知道了什么是链表了，那么我们首先要考虑的就是这个链表中的节点该怎么定义，还记得链表的结构吧，它长这个样子：（这里是单链表）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200219224747924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
在链表中，都是由一个个的节点组成的，所以我们在实现单链表的时候，首先就是要定义一个节点，在Java中，万物皆对象啊，所以嘞，我们首先要想到把节点用一个类来表示，也就是一个节点类，那么这个类名称叫啥嘞，一般就是Node了，来来，写代码啦

```java
class Node{
}
```
这里定义一个Node嘞，链表中的一个节点是这样的：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200219225026231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
包括两个部分，一个是真得数据，一个是保存下一个对象的next指针，其实就是下一个Node对象的引用，所以我们接着写代码：

```java
class Node{
	//真实数据
	int data;
	//next指针，指向下一个节点对象
	Node next;
}
```
这样就ok了吗？我们想下，链表归根到底是用来保存数据的，那么我们创建一个节点的时候是不是应该往里面塞数据啊，这个代码怎么来呢？很容易想到啊，可以通过构造函数啊，就是这样啦：

```java
   class Node{
        //结点数据
        int data;
        //结点指针
        Node next;
        //无参构造函数
        public Node(int data){
            this.data = data;
        }
    }
```
ok，这样一个节点我们就定义好了，现在有节点了，我们就开始写我们的单链表了，首先起个名字吧，就叫做MyLinkedList吧。

## 增加节点
接下来我们就实现第一个功能，那就是增加节点啊，这里其实涉及不少问题，什么哨兵节点，什么头插，什么尾插以及中间插入嘞，我们不搞那么麻烦，我们先设定一个场景前提：

> 本来没有链表，我们要创建一个出来，然后增加的话直接在尾部追加即可

这个很好理解吧，那么我们就开始写代码吧：

```java
public class MyLinkedList {
    //定义一个头结点
    Node head;
    //链表的长度
    int size;
}
```
这里我们首先需要定义一个头结点，为啥要定义这个头结点嘞，因为一个链表，咋弄也得先有一个节点，然后一个连着一个的增加吧，所以只有有了头结点，也就是第一个节点，剩下的才顺理成章啊，对了，把我们定义的节点类也放进去，这时候是内部类的方式：

```java
public class MyLinkedList {
    //定义一个头结点
    Node head;
    //链表的长度
    int size;
    
	//创建结点
    class Node{
        //结点数据
        int data;
        //结点指针
        Node next;
        //无参构造函数
        public Node(int data){
            this.data = data;
        }
    }
}
```
写我们的增加节点的方法：

```java
 //增加节点，顺序插入，也就是在尾部追加数据
    public void addNode(int data){
	}
```
想想怎么写，我们首先想到的就是现在还没有链表嘞，我们增加第一个数据那就是增加的头结点啊，所以先对头结点进行处理：

```java
 //增加节点，顺序插入，也就是在尾部追加数据
    public void addNode(int data){
    	 //头结点的处理
        if(head == null){
            head = new Node(data);
            size++;
            return;
        }
	}
```

这个逻辑简单，不用再多加解释吧，这其实就是第一次增加节点的时候也就是创建头结点的操作，如此一来，就有了一个头结点，接下来呢？这是增加头结点可以这么来，那接下里增加新的节点就是把新的节点跟在前一个节点的后面，一个个链接起来吧，那这个该怎么操作嘞？

```java
//遍历到尾结点
        Node temp = head;
        while (temp.next != null){
            temp = temp.next;
        }
        //找到尾结点，赋值
        temp.next = new Node(data);
        size++;
```
代码就是上面这样的，就这些代码，第一次写链表代码的同学要好好理解并且要记住了，这里的核心就是遍历找到链表的尾结点，为啥，因为我们再次添加新节点，之前规定了就是在尾部追加啊，所以我们重点就是要找到这个尾部代码，接下来就是理解为啥要写这么一句代码：

```java
Node temp = head;
```
为啥要定义一个临时节点出来呢？首先你想啊，我们要遍历找到尾结点，肯定是从头结点遍历，但是现在我们又不知道这个尾结点是谁，头结点又是固定的，因此我们需要定义一个新的临时节点，从头结点开始，可以一次向后移动，移动到尾结点的时候把其复制成尾结点，这样一来就好表示了，仔细想想。

然后就是这个循环代码：

```java
 while (temp.next != null){
            temp = temp.next;
        }
```
显而易见啊，这个就是遍历找到尾结点啊，temp的next就是指的头结点后面的节点，如果不为空，说明头结点后面还有节点，那么就把这个临时节点继续后移，怎么后移嘞，现在这个temp指向头结点，对吧，这个知道吧，后移的的话也就是指向头结点的后一个节点，那不就是把头结点的后一个节点赋值给这个临时节点嘛，正是这样：

```java
temp = temp.next;
```
然后直到找到这个临时节点后面没有节点了，也就是为空了，执行这些代码：

```java
//找到尾结点，赋值
        temp.next = new Node(data);
        size++;
```
此时这个临时节点temp指向的就是尾结点了，然后在气候追加新的节点，就是为其next赋值新节点。

如此一来，增加节点这个操作我们就完成了，整体代码如下：

```java
 /**
     * 增加节点，顺序插入，也就是在尾部追加数据
     * @param data
     */
    public void addNode(int data){
        //头结点的处理
        if(head == null){
            head = new Node(data);
            size++;
            return;
        }
        //遍历到尾结点
        Node temp = head;
        while (temp.next != null){
            temp = temp.next;
        }
        //找到尾结点，赋值
        temp.next = new Node(data);
        size++;
    }
```
## 删除节点
知道如何新增节点了，接下来我们就要看看如何删除节点了，首先，我们看看如下的链表：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200219232018919.png)
我们看这个链表，如果我们删除数据2的话，是不是就要把数据1的next指向数据3，也就是数据1.next = 数据3，脑海中要有这个概念。

接下来我们看看这个删除的代码该怎么写，写这个删除的话，我们得考虑依据什么来删除，我们之前定义了一个size来代表链表的长度，增加一个节点就加一，你想是不是可以看做这些链表节点根据加入的先后顺序被编号了，也就是有了索引，那么我们这里删除的时候就根据这个索引来删除。

然后我们得考虑了，有这么些特殊情况：

```java
public Node deleteNode(int index){
        //处理空链表
        if (size == 0){
            return null;
        }
        //处理异常索引
        if (index < 1 || index > size){
            return null;
        }
        //删除头结点
        if (index == 1){
            Node temp = head;
            head = head.next;
            size--;
            return temp;
        }
}
```
首先就是空链表，然后还有越界索引，这个我想都好理解，我就不多说了，我们写的这个删除节点的代码会返回被删除的这个节点，在处理头结点的时候，删除头结点要返回头结点该怎么返回嘞，我这里的鹅湖粗粒是定义一个临时节点指向最开始的这个头结点，更新了头结点之后把原先的返回，这些代码没什么复杂，就不多说了。

我们接下来看，出去这些特殊情况，我们删除后续节点该怎么操作，想想上面说的那三个节点数据删除数据2的操作，这个时候你得明确，我们根据索引去删除，再次删除的一定不是头结点了，因为头结点已经按照特殊情况去处理了，所以我们再次删除，就要看看这个索引是啥，我们需要遍历，找到这个索引对应的节点。

你想啊，此时我们遍历是不是就是从链表的第二个节点开始，所以我们先定义一个索引值int i = 2，知道为啥等于2吧，这就代表链表中的第二个节点，然后要删除的节点的索引是index，我们就需要找到这个i == index的情况就找到要删除的节点了。

然后，我们仔细看看下面这个图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200219234557963.png)
其实现在我们只知道头结点，然后要从头结点下一个节点去遍历，我们怎么表示这个遍历的起点呢？我们把这个当做当前节点，用cureNode来表示，这个其实也好表示，不说就是head.next嘛，而且此时这个当前节点的索引是2，这都好理解吧，假如说啊，这个index就是2，说明我们删除的节点就是头结点之后的这个节点，那么是不是就是把头结点的next指向当前节点的next所指的节点呢？代码表示就是：

```java
head.next = cureNode.next;
```
当然，这里不应删除的就是头结点之后的节点，所以统一来说：

> 如果我们要删除当前节点，就需要让当前节点的上一个节点的next指向当前节点的next所指向的对象

代码表示就是：

```java
preNode.next = cureNode.next;
```
那么思考下，这里的cureNode和preNode最初该怎么表示，想想，我们最初只知道头结点的，所以这个当前节点是不是就是：

```java
 Node cureNode = head.next;
```
而这个preNode不就是头结点嘛：

```java
Node preNode = head;
```
所以啊，我们删除除特殊情况外的节点代码就可以这样写：

```java
//删除非头结点
        //从头结点的下一个节点开始遍历
        Node cureNode = head.next;
        //记录当前循环的节点的上一个节点用于删除当前节点
        Node preNode = head;
        int i = 2;
        while (cureNode != null){
            if (i == index){
                //要删除的就是此节点
                preNode.next = cureNode.next;
                size--;
                break;
            }else {
                preNode = cureNode;
                cureNode = cureNode.next;
                i++;
            }
        }
        return cureNode;
```
然后返回删除的当前节点，另外要注意的就是这段代码：

```java
preNode = cureNode;
cureNode = cureNode.next;
i++;
```
这个其实就是往下继续遍历，知道找到要删除的那个节点，把cureNde和preNode依次往后移动。

这么一来删除节点的代码就搞定了，整体代码如下：

```java
/**
     * 删除节点，根据索引删除
     * @param index
     * @return
     */
    public Node deleteNode(int index){
        //处理空链表
        if (size == 0){
            return null;
        }
        //处理异常索引
        if (index < 1 || index > size){
            return null;
        }
        //删除头结点
        if (index == 1){
            Node temp = head;
            head = head.next;
            size--;
            return temp;
        }
        //删除非头结点
        //从头结点的下一个节点开始遍历
        Node cureNode = head.next;
        //记录当前循环的节点的上一个节点用于删除当前节点
        Node preNode = head;
        int i = 2;
        while (cureNode != null){
            if (i == index){
                //要删除的就是此节点
                preNode.next = cureNode.next;
                size--;
                break;
            }else {
                preNode = cureNode;
                cureNode = cureNode.next;
                i++;
            }
        }
        return cureNode;
    }
```

## 该怎么打印链表嘞？

一般的啊，我们还要搞一个打印链表的操作，这是为了看到链表的内容，方便做一些测试啊，那么该怎么打印链表啊，咋一看，一想好像摸不着头脑，再仔细一想，我擦，不就是从头结点开始遍历，然后分别打印出每个节点的data数据吗？

来来，直接上代码：

```java
/**
     * 打印链表
     */
    public void printList(){
        Node curNode = head;
        //循环遍历到尾结点
        while (curNode != null){
            System.out.print(curNode.data + " ");
            curNode = curNode.next;
        }

        System.out.println();

    }
```
经过上面新增节点和删除节点的剖析，这段代码不在话下吧，就不多说啦。

## 返回链表长度
这个其实我觉得还是很有必要的，虽然真的超级简单：

```java
 /**
     * 返回链表长度
     */
    public int getSize(){
        return size;
    }
```
## 差不多啦，测试一下
到这里我们就完成了最基本和最简单的增加，删除和打印链表，我们来测试下看看，先增加几个节点，然后打印看下链表长度：

```java
 MyLinkedList myLinkedList = new MyLinkedList();
        myLinkedList.addNode(10);
        myLinkedList.addNode(20);
        myLinkedList.addNode(30);
		myLinkedList.printList();
        System.out.println("链表长度= " + myLinkedList.getSize());
```
测试结果如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200219235940339.png)
吆西，像那么回事啊，删除一个试试（删除头结点）：

```java
//删除链表节点
        MyLinkedList.Node node = myLinkedList.deleteNode(1);
        System.out.println("删除的节点数据是：" + node.data);

        myLinkedList.printList();
        System.out.println("链表长度= " + myLinkedList.getSize());
```
测试结果是：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200220000143493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
不赖啊，继续删除其他节点试试，比如删除最后一个：

```java
 MyLinkedList.Node node = myLinkedList.deleteNode(3);
```
测试结果是：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200220000310766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
阔以，是那么一回事😂

## 这就是渣渣代码
实话说，上面的代码实现真不怎么滴，可以优化的地方有很多，也有很多考虑不周的地方，但是这里不是为了要实现一个多美完美的单链表代码，而是通过实现一些简单的基本的功能，来告诉大家，多敲代码很重要，你不敲，你第一次真的写不出来，即使自己动手了，也不定写的出来，即使写出来了，bug也非常多。

但是还是那句话：好文章都是修改出来的，代码也是如此！

当你开始写的那一刻，你就迈出了一大步，你只会越来越好，代码写的越来越流畅，理解的也越来越深刻，代码能力就是这么提升上来的。

另外，很多人问，学编程有什么不二法门吗？

答案是有的，啥嘞，四个字“多看多练”，尤其多练！

朋友们，拿起你的键盘，敲起来吧！

# 来吧！一文彻底搞定哈希表！

## 哈希表是个啥？

**小白**： 庆哥，什么是哈希表？这个哈希好熟悉，记得好像有HashMap和HashTable之类的吧，这是一样的嘛？😊

**庆哥：** 这个哈希确实经常见😂，足以说明它是个使用非常频繁的玩意儿，而且像你说的HashMap和HashTable之类的与哈希这个词肯定是有关系的，那哈希是个啥玩意啊，这个咱们还是得先来搞明白啥是个哈希表。😎

我们看看百科解释吧：

> **散列表**（**Hash table**，也叫**哈希表**），是根据[键](https://zh.wikipedia.org/wiki/鍵)（Key）而直接访问在内存存储位置的[数据结构](https://zh.wikipedia.org/wiki/数据结构)。也就是说，它通过计算一个关于键值的函数，将所需查询的数据[映射](https://zh.wikipedia.org/wiki/映射)到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做[散列函数](https://zh.wikipedia.org/wiki/散列函数)，存放记录的数组称做**散列表**。

怎么样？看到这个，你知道哈希表是什么了嘛？

**小白：** 我之前是对哈希表一窍不通啊，不过看了这个百科的解释，我知道如下这些关于哈希表的简单知识点：

1、哈希表其实也叫散列表，两个是一个玩意，英文是Hash Table

2、哈希表是一个数据结构

这两个概念是比较清晰的，至于其他的说什么映射函数叫做散列函数，存放记录的数组叫做散列表这个就有点模糊了，尤其说存放记录的数组称为散列表，那意思是哈希表是个数组？🤣

**庆哥：** 首先你说的很清晰的两点说的是很准确的，哈希表也叫做散列表，这只不过是叫法而已，英文单词是Hash table，看到这个英文单词基本上就能猜到，哈希表其实就是直接根绝英文单词音译过来的，至此你应该知道了啥是哈希了吧，对于另外一点，那就很重要了，那就是`哈希表其实是一种数据结构。`

要知道数据结构有很多中，每一种都有各自的特点，那么哈希表既然也是一种数据结构，那它有什么特点呢？按照百科的解释，我们大致能知道：**可以根据一个key值来直接访问数据，因此查找速度快**

对了，你知道最基本的几个数据结构中，哪个的查询效率是最高的嘛？

**小白：** 据我所知，应该是数组吧，我们可以直接使用数组下标来访问数据，因此查询效率是很高滴😁

**庆哥：** 对，非常对，哈希表其实本质上就是一个数组 。

**小白：** 那为啥还叫哈希表呢？🤣，哈希表肯定有啥特别的吧，为啥本质上是一个数组呢？

## 哈希表本质是数组？

**庆哥：** 必须滴啊，哈希表本质上是个数组，只能说它的底层实现是用到了数组，简单点说，在数组的这个基础上再捯饬捯饬，加工加工，变得更加有特色了，然后人家就自立门户，叫**哈希表**😂

**小白：** 这是咋个回事啊🤣

**庆哥：** 为什么说哈希表的本质是个数组呢？那就得看看，哈希表是怎么来实现的了，一般来说啊，实现哈希表我们可以采用两种方法：

1、数组+链表

2、数组+二叉树

简单点就有这么两种方式，其实说白了，无论哪个都是必须有数组啊，都是再数组的基础上取搞其他的，而且比如第一种数组+链表的形式，本质上是出现哈希冲突的一种解决办法，使用链表存放，所以综合起来叫做数组+链表的方式来实现一个哈希表，另外数组中一般就是存放的单一的数据，而哈希表中存放的是一个键值对，这是个区别吧！

**小白：** 停！！！有点迷糊🤣，什么哈希冲突，什么玩意儿啊😂

**庆哥：** 🤪，好吧好吧，我说的有点着急了😂，你就记住，哈希表在本质上就是个数组就ok了。

**小白：** 可是我还是像知道为啥啊？🤣

**庆哥：** 别着急啊，咱慢慢来讲，另外在百科上有这么一个例子，可以帮助你更好的理解哈希表是个啥，它是这样说的：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191202103427529.png)

怎么样？看的懂嘛？

**小白：** 反正是有点模糊，这其中提到的函数关系啊，关键字啊，散列函数还有什么函数法则的有点迷迷糊糊的🤣

## 哈希表的几个概念

### 啥是散列函数

**庆哥：** 确实，这都是哈希表中很重要的几个概念，那咱就先搞懂这几个概念吧，我用大白话给你说说这个例子。😎

比如说，我现在给你个电话本，上面记录的有姓名和对应的手机号，我想让你帮我找王二的手机号是多少，那么你会怎么做呢？

**小白：** 这样啊，那我就挨个找王二呗？😀

**庆哥：** 确实可以，那么你有没有想过，如果这个王二是在最后几页，那你去岂不是前面几页都白找了，有没有更快的方式呢？

**小白：** 也是哦，那这样的话，是不是可以按照人名给分个类，比如按照首字母来排序，就abcd那样的顺序，这样根据王二我就知道去找w这些，这样不久快很多了😁

**庆哥：** 的确，我们可以按照人名的首字母去弄一个表格，比如像这样：

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2l0aHVhbmdxaW5nL215aW1nL21hc3Rlci9pbWcvMjAxOTEyMDEyMjUwMjIucG5n?x-oss-process=image/format,png)

你看，假如现在我让你去帮我找王二的手机号，你一下子就能找到，不用再挨个的去查找了，这效率就高的多了，那么现在重点来了，人家本来叫王二，你为啥用一个w来标记人家呢？让你找王二为啥你不直接找王二而是去找w呢？

**小白：** 这个？😅，用w可以更快速的去定位到王二啊😂

**庆哥：** 说的很对，我们取姓名的首字母作为一个标志，就可以很快的找到以这个字母开头的人名了，那么王二也就能更快的被我们找到，我们也不用再费力气去找什么张二和李二的，因为人家的名字首字母都不是w。

**小白：** 那必须啊，这个方法好吧😁

**庆哥：** 对对对，你说到点子上了，那就是方法二字，这里我们就是采用一种方法，什么方法呢？那就是取姓名的首字母做一个排序，那么这是不是就是通过一些特定的方法去得到一个特定的值，比如这里取人名的首字母，那么如果是放到数学中，是不是就是类似一个函数似的，给你一个值，经过某些加工得到另外一个值，就像这里的给你个人名，经过些许加工我们拿到首字母，那么这个函数或者是这个方法在哈希表中就叫做散列函数，其中规定的一些操作就叫做函数法则，这下你知道什么是散列函数了吧😎

**小白：** 嗯呢，这下真的是很清楚了，说白了，不就是给我一个值，经过捯饬一下，变成另外一个值吗？花个图的话就是这个样子：

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2l0aHVhbmdxaW5nL215aW1nL21hc3Rlci9pbWcvMjAxOTEyMDEyMzA1NTMucG5n?x-oss-process=image/format,png)

哈哈，是不是这样？😂

**庆哥：** 简单来说就是这样滴😎，咋样，这下知道什么是散列函数了吧？

### 关键值key是啥？

**小白：** 这下知道了，很清楚😎，那这个关键字key是个啥玩意？

**庆哥：** 这个也好理解啊，就像你画的这个图，1是怎么得出来得，是不是根据未加工之前得101得出来得，这个加工过程其实就是个散列函数，而丢给它的这个101就是这个关键值啊，为啥叫它关键值嘞，那是因为我们要对它做加工才能得出我们想要的1啊，你说它关不关键😂

**小白：** 哦哦，原来是这样啊，这下就明白啦！对了，我现在有这样的一个理解，你看看对不对啊，那就是哈希表就是通过将关键值也就是key通过一个散列函数加工处理之后得到一个值，这个值就是数据存放的位置，我们就可以根据这个值快速的找到我们想要的数据，是不是这样啊？😂

**庆哥：** 说的很正确😎，那你现在对之前那个百科的例子懂了嘛？

**小白：** 嗯呢，这下懂了😀

**庆哥：** 嗯呢，那就好，其实吧，上面的那中情况并不好，为啥嘞？你想啊，王二在那个位置，如果再来个王三呢？人家的首字母也是w啊，这咋办，位置被王二占了，那王三咋办？这就是哈希冲突啊，撞衫啦🤣

**小白：** 阿西吧，又是哈希冲突，它到底似乎个啥玩意啊😂

**庆哥：** 不着急，咱们继续来探究哈希表。

## 再探哈希表

**庆哥：** 我们在之前已经知道了哈希表的本质其实是个数组，数组有啥特点啊？

**小白：** 数组嘛，那就是下表从0开始啊，连续的，直接通过下标访问，比如下面这样：

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2l0aHVhbmdxaW5nL215aW1nL21hc3Rlci9pbWcvMjAxOTEyMDEyMzMyMjEucG5n?x-oss-process=image/format,png)

有一个数组a，我们可以直接通过a[1]的形式来访问到数值7，所以查询效率很高。

**庆哥：** 完全正确，那么哈希表本质上是个数组，那它跟这个类似吗？我们来再深入探究一下，首先看个图：

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2l0aHVhbmdxaW5nL215aW1nL21hc3Rlci9pbWcvMjAxOTEyMDEyMzM1MDIucG5n?x-oss-process=image/format,png)

这张图可是信息量很大啊，你看出来个啥了嘛？

**小白：** 这个？我看到了哈希函数，这是啥？它跟散列函数有啥区别啊？还有Entry是个什么鬼😂，还有键值对🤣，蒙圈啊😥

### 哈希函数

**庆哥：** 别蒙圈啊，我来仔细跟你说说，其实这个哈希函数就是我们之前说的散列函数，为啥嘞？这就跟哈希表也叫做散列表一样啊，你叫作散列表的时候有个散列函数，那你叫哈希表的时候，也得有个哈希函数啊，这样才公平嘛😀，咋样，知道了吧？

**小白：** 我去，原来是这么回事啊🤣，那键值对跟Entry嘞？

### 键值对和Entry

**庆哥：** 这个可是值得好好说道说道，我们知道哈希表本质上是个数组，难道就跟数组的基本使用那样，存个数值，然后通过下表读取之类的嘛？当然不是啦，对于哈希表，它经常存放的是一些键值对的数据，啥是键值对啊，就是我们经常说的key-value啊，简单点说就是一个值对应另外一个值，比如a对应b，那么a就是key，b是value，哈希表存放的就是这样的键值对，在哈希表中是通过哈希函数将一个值映射到另外一个值的，所以在哈希表中，a映射到b，a就叫做键值，而b呢？就叫做a的哈希值，也就是hash值。

咋样，这块明白了嘛？

**小白：** 嗯嗯，明白的，庆哥继续！😎

**庆哥：** 那好，我们继续，键值对说的简单点就是有一个key和一个value对应着，比如这张图里的学生信息：

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2l0aHVhbmdxaW5nL215aW1nL21hc3Rlci9pbWcvMjAxOTEyMDEyMzM1MDIucG5n?x-oss-process=image/format,png)

学生的学号和姓名就是一个键值对啊，根据这个学号就能找到这个学生的姓名，那啥是Entry嘞，我们都知道键值对，在很多语言中也许都有键值对，说白了就是个大众脸啊，咋弄，在咱jdk中可不能那么俗气，不能再叫键值对了，叫啥嘞，那就叫Entry吧😂

咋样，知道啥是键值对和Entry了吧！

**小白：** 必须滴啊，讲的那么生动😁，这张图感觉远不止如此啊，庆哥继续啊😜

### 哈希表如何存数据

**庆哥：** 好滴，那咱们就继续，来说说哈希表是如何存放数据的，记得看上面的图啊，我们按照这个图来说，我们已经知道了哈希表本质是个数组，所以这里有个数组，长度是8，现在我们要做的是把这个学生信息存放到哈希表中，也就是这个数组中去，那我们需要考虑怎么去存放呢？

这里的学号是个key，我们之前也知道了，哈希表就是根据key值来通过哈希函数计算得到一个值，这个值就是用来确定这个Entry要存放在哈希表中的位置的，实际上这个值就是一个下标值，来确定放在数组的哪个位置上。

比如这里的学号是101011，那么经过哈希函数的计算之后得到了1，这个1就是告诉我们应该把这个Entry放到哪个位置，这个1就是数组的确切位置的下标，也就是需要放在数组中下表为1的位置，如图中所示。

我们之前已经介绍过什么是Entry了，所以这里你要知道，数组中1的位置存放的是一个Entry，它不是一个简单的单个数值，而是一个键值对，也就是存放了key和value，key就是学号101011，value就是张三，我们经过哈希函数计算得出的1只是为了确定这个Entry该放在哪个位置而已。

现在我们就成功把这个Entry放到了哈希表中了，怎么样，这块听懂了嘛？

**小白：** 嗯嗯，听懂了，不过看到这里我产生了一个疑问，那就是这个哈希函数，是不是有一个特定的加工过程，比如可以经过某种计算把101011转换成1，那么有没有可能其他的学号经过哈希函数的计算也得出1呢？那这个时候是不是就撞衫啦😂

### 哈希冲突

**庆哥：** 的确，你分析得很正确，我们再来看下面这张图：

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2l0aHVhbmdxaW5nL215aW1nL21hc3Rlci9pbWcvMjAxOTEyMDIwMDE0NDUucG5n?x-oss-process=image/format,png)

你说的这种情况就像图中展示的那样，学号为102011的李四，他的学号经过哈希函数的计算也得出了1，那么也要放到数组中为1的位置，可是这个位置之前已经被张三占了啊，这怎么办？这种情况就是哈希冲突或者也叫哈希碰撞。

既然出现了这情况，不能不管李四啊，总得给他找个位置啊，怎么找呢？

**小白：** 我猜肯定有什么方法可以给李四找位置🤣

### 处理哈希冲突

**庆哥：** 那必须滴啊😄，有什么方法呢？其实关于哈希冲突的解决办法有好几种嘞，但是我这里只介绍两种主要的方法，一个是开放寻址法，一个是拉链法。

那什么是开放寻址法呢？我们继续来看图：

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2l0aHVhbmdxaW5nL215aW1nL21hc3Rlci9pbWcvMjAxOTEyMDIwMDI0MTAucG5n?x-oss-process=image/format,png)

我觉得看图就足以说明问题了，这里所说的开放寻址法其实简单来说就是，既然位置被占了，那就另外再找个位置不就得了，怎么找其他的位置呢？这里其实也有很多的实现，我们说个最基本的就是既然当前位置被占用了，我们就看看该位置的后一个位置是否可用，也就是1的位置被占用了，我们就看看2的位置，如果没有被占用，那就放到这里呗，当然，也有可能2的位置也被占用了，那咱就继续往下找，看看3的位置，一次类推，直到找到空位置。

对了，Java中的ThreadLocal就是利用了开放寻址法。

**小白：** 啥是ThreadLocal啊😂

**庆哥：** 咋滴，你不知道啊，没事，给你一篇文章，看了包装你再也不学ThreadLocal了，因为看完这篇，你就再也忘不掉啦，链接直达，走起：[再也不学ThreadLocal了，看这一篇就忘不掉了！（万字总结）](https://blog.csdn.net/sinat_33921105/article/details/103295070)

**小白：** 嗯嗯，我会好好看看的。那什么是拉链法啊？

**庆哥：** 拉链法也是比较常用的，像之前你说的HashMap就是使用了这种方法，那这个方法是怎么个回事呢？我们继续来看图：

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2l0aHVhbmdxaW5nL215aW1nL21hc3Rlci9pbWcvMjAxOTEyMDIwMDM0MDUucG5n?x-oss-process=image/format,png)

之前说的开放寻址法采用的方式是在数组上另外找个新位置，而拉链法则不同，还是在该位置，可是，该位置被占用了咋整，总不能打一架，谁赢是谁的吧😂，当然不是这样，这里采用的是链表，什么意思呢？就像图中所示，现在张三和李四都要放在1找个位置上，但是张三先来的，已经占了这个位置，待在了这个位置上了，那李四呢？解决办法就是链表，这时候这个1的位置存放的不单单是之前的那个Entry了，此时的Entry还额外的保存了一个next指针，这个指针指向数组外的另外一个位置，将李四安排在这里，然后张三那个Entry中的next指针就指向李四的这个位置，也就是保存的这个位置的内存地址，如果还有冲突，那就把又冲突的那个Entry放在一个新位置上，然后李四的Entry中的next指向它，这样就形成了一个链表。

好啦，这就是拉链法，咋样，明白不😎

**小白：** 信息量不少啊，好在庆哥讲的比较清楚，明白啦😀

**庆哥：** 明白了就好，那我问你一个问题啊，针对开放寻址和拉链法，你有没有觉得会产生什么问题呢？

**小白：** 嗯嗯，我还真有问题，首先是这个拉链法啊，如果冲突的很多，那这个增加的链表岂不是很长，这样也不咋好吧😂

**庆哥：** 的确，如果冲突过多的话，这块的链表会变得比较长，怎么处理呢？这里举个例子吧，拿java集合类中的HashMap来说吧，如果这里的链表长度大于等于8的话，链表就会转换成树结构，当然如果长度小于等于6的话，就会还原链表。以此来解决链表过长导致的性能问题。

**小白：** 为啥是小于等于6啊，咋不是7嘞😂

**庆哥：** 这样设计是因为中间有个7作为一个差值，来避免频繁的进行树和链表的转换，因为转换频繁也是影响性能的啊。

**小白：** 嗯嗯，这个知道了，关于开放寻址也有个疑问，那就是如果一直找不到空的位置咋整啊？🤣

**庆哥：** 这个不会的，为啥嘞？你这样想，是因为你考虑了一个前提，那就是位置已经被占光了，没有空位置了，但是实际情况是位置不会被占光的，因为有一定量的位置被占了的时候就会发生扩容。

**小白：** 阿西吧，还有扩容，那这个扩容是咋回事呢？

### 哈希表的扩容

**庆哥：** 其实这里不仅仅是因为你说的那种情况才会扩容，还有一个很重要的原因就是当哈希表被占的位置比较多的时候，出现哈希冲突的概率也就变高了，所以很有必要进行扩容。

那么这个扩容是怎么扩的呢？这里一般会有一个增长因子的概念，也叫作负载因子，简单点说就是已经被占的位置与总位置的一个百分比，比如一共十个位置，现在已经占了七个位置，就触发了扩容机制，因为它的增长因子是0.7，也就是达到了总位置的百分之七十就需要扩容。

还拿HashMap来说，当它当前的容量占总容量的百分之七十五的时候就需要扩容了。

而且这个扩容也不是简单的把数组扩大，而是新创建一个数组是原来的2倍，然后把原数组的所有Entry都重新Hash一遍放到新的数组。

**小白：** 这个重新Hash一遍是啥意思啊？

**庆哥：** 因为数组扩大了，所以一般哈希函数也会有变化，这里的Hash也就是把之前的数据通过新的哈希函数计算出新的位置来存放。

**小白：** 嗯嗯，原来是这么回事啊，懂了，对了，那哈希表的数据读取怎么操作的啊？

### 哈希表如何读取数据

**庆哥：** 要知道这个读取操作，我们还来看这个图：

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2l0aHVhbmdxaW5nL215aW1nL21hc3Rlci9pbWcvMjAxOTEyMDIwMDM0MDUucG5n?x-oss-process=image/format,png)

比如我们现在要通过学号102011来查找学生的姓名，怎么操作呢？我们首先通过学号利用哈希函数得出位置1，然后我们就去位置1拿数据啊，拿到这个Entry之后我们得看看这个Entry的key是不是我们的学号102011，一看是101011，什么鬼，一边去，这不是我们要的key啊，然后根据这个Entry的next知道下一给位置，在比较key，好成功找到李四。

**小白：** 哦哦，原来是这么回事啊，那对于开放寻址那种是不是也是这个思路，先确定到这个位置，然后再看这个位置上的key是不是我们要的，如过不是那就看看下一个位置的。

**庆哥：** 可以的，完全正确，好了现在我们对哈希表的讲解已经差不多了，那么你觉得对于哈希表而言，什么是核心呢？

## 哈希函数是核心

**小白：** 我觉得应该是哈希函数吧，经过上面的讲解，我觉得，如果一个哈希函数设计的足够好的话，就会减少哈希冲突的概率，如果设计的不好，那就会经常撞衫😂，那就很影响性能了，比如刚开始我们举的那个例子，拿姓名的首字母来确定位置，这个哈希函数的设计就不咋滴，比如王二，王三，王四什么的，这都会冲突啊😂

**庆哥：** 的确，在哈希表中，哈希函数的设计很重要，一个好的哈希函数可以极大的提升性能，而且如果你的哈希函数设计的比较简单粗陋，那很容易被那些不怀好意的人捣乱，比如知道了你哈希函数的规则，故意制造容易冲突的key值，那就有意思了，你的哈希表就会一直撞啊，一直撞啊😂

**小白：** 哈哈😂，那设计哈希函数有什么方法吗？

**庆哥：** 必须有啊，比如有直接定址法，数字分析法，折叠法，随机数法和除留余数法等等，要不要继续讲啊😀

**小白：** 我去🤣，还是不要了吧，消化不了啊，这次先到这吧，谢谢庆哥😘

# 来吧！一文彻底搞定数据结构之树！

**庆哥：** 小白啊，知道什么是树吗？😃

**小白：** 啥玩意？什么是树😕，我也是受过九年义务教育的啊，不知道什么是树那还得了，不就是杨条啊，春树啊😎

**庆哥：** 等等😅，杨条是什么鬼啊😹，我说的此树非彼树啊，我说的是数据结构中的概念😃

**小白：** 尴了个大尬😂，数据结构中的树啊，经常看但是说不上来😥，庆哥给我讲讲吧，最好大白话的去讲，我理解力差😅

**庆哥：** 可以可以，我最擅长大白话解释复杂概念了，走起，安排上😎

## 什么是树？数据结构中的
**庆哥：** 我们之前已经讲过数组，链表，栈和队列以及哈希表，链接在这里：

[来吧！给你不一样的数组深入讲解！](https://blog.csdn.net/sinat_33921105/article/details/103453679)

[轻轻松松学会栈和队列（附有顺序栈的实现思路分析）](https://blog.csdn.net/sinat_33921105/article/details/103673904)

[链表不会？看这个立马就懂！](https://blog.csdn.net/sinat_33921105/article/details/103434447)

[来吧！一文彻底搞定哈希表！](https://blog.csdn.net/sinat_33921105/article/details/103344078)

这都是很重要的数据结构哦，建议都读读哦，毕竟是我那么用心写的😄，今天咱就来说说数据结构中的这个树，其实吧，这里的树和真实我们见到的那些树木还是有关联的，不然为什么在数据结构中也叫树呢？

那你想想，在数据结构中为什么叫树呢？😏

**小白：** 像这样的情况，我觉得一般就是形似，也就是结构应该差不多，数据结构中的树这种结构应该和树的形状有关联😆

**庆哥：** 哈哈，聪明，数据结构中的树就是和现实中的树长得差不多，我们来看看现实中的树是不是都类似这个样子：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200114000148729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
哈哈，我这里画的只是个模拟图，大致就这样，一棵树有树干，然后有各个树枝，然后还有各种叉子😂

**小白：** 嗯嗯，画的不赖😄，那数据机构中的树也是这样？

**庆哥：** 数据结构中的树是这样的：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200114000842175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
这就是数据结构中用树这个结构去存储集合{A,B,C,D,E,F,G,H,I,J,K,L,M} 的示意图了，它和树有相似的地方，准确来说应该反着看和树的形状更像，你就记住，树结构和真实的树形状类似，现在你先不用管其他的，先来看这个图，你看看这其中的每个数据，也就是ABC那些有什么关系呢？

**小白：** 这样啊，每个数据之间都是连着的，这是不是说明每个数据之间都是有关系的，就比如数据A与B,C,D都有关系。

**庆哥：** 是的，我们在之前介绍的数组，链表，栈和队列等等都是线性存储结构，但是我们今天要介绍的这个树结构则不是线性结构了，对于线性结构，它们的数据基本上是hi一对一的关系，但是树结构从上面的图中也可以看得出来，它是一对多的关系，所以树结构是一种非线性数据结构，存储的数据是具有一对多的特点。

从图中我们看得出来比如A数据是和B,C,D都有关系的，再拿数据B来说，它是与E和F都有关系的，因此啊，我们把这种存储结构叫为“”树型“”存储结构

**小白：** 晓得了😎，就是这种结构跟树的结构差不多，树干上有树枝，每个树枝上可能还有其他小树枝，对吧😂

**庆哥：** 完全正确😄，接下来我们继续学习关于树的几个概念，对了，我们接下来说的树可都是指的树型结构，可不是你说的杨条哦😅

**小白：** 🤣

## 关于树的节点
那什么是节点呢？

**庆哥：** 关于这里，我发现有叫做节点，也有叫做结点的，反正都是一个意思啦，那什么是节点啊，其实也很简单，看图你就能猜得出来什么是节点？毕竟你是接受过九年义务教育的😄

**小白：** 我猜啊，这个节点应该指的就是树结构中的每一个数据啊，也就是下图的每一个圆圈😂

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200114000842175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

**庆哥：** 对的，就是这样的，比如图中的数据A或者B，它其实就是一个节点，那么怎么定义这个节点呢？

> 节点：使用树结构存储的每一个数据元素都被称为“节点”。比如 A 就是一个节点

### 根节点

那就这个节点来说，图中每个数据其实都是一个节点，但是根据每个节点所处的位置不同，它们还有各自独特的命名，什么嘞？你看啊，比如图中的A节点，你看看它是不是很特殊？

**小白：** 确实啊，最上面，老大节点😂

**庆哥：** 什么啊😅，准确来说，它是根节点，为啥叫根节点，你想，如果是一棵树的话，它是不是相当于在最下面，类似树根了，说一也叫作树根节点，简称根节点😁，然后你再看，它还有什么特点？

**小白：** 还有什么嘞？哦哦，它应该只有一个吧，也就是说只有一个根节点，一棵树不可能有两个树根吧😅

**庆哥：** 说的很对，对于树结构来说，它只有一个根节点，那怎么来给根节点下一个定义呢？那要来看另外一个节点叫做父节点

### 父节点，子节点和兄弟节点

**庆哥：** 那什么是父节点嘞？你说😎

**小白：** 父节点？这个有点懵啊😅

**庆哥：** 这个也好理解啊，父节点，就是父亲，儿子和兄弟这些概念😂，你看图中的B，它就是一个父节点，这个其实要找一个参照来说，不能孤立的来说哪个是父节点，对于B来说，E和F在它的下面，所以有这么一个关系就是B是E和F的父节点，而E和F是它们的子节点，这么一说好理解吧😀

在这里，这个父节点也可以叫做双亲节点，而子节点也可以叫做孩子节点，怎么样，这些概念名词都很形象化啊🤣

**小白：** 你这么一说倒是清楚的很😂

### 叶子节点

**庆哥：** 然后还有一个叶子节点的概念，这个更好理解，叶子节点，叶子，不就是树叶子吗😂，那你说哪些是叶子节点

**小白：** 这个啊，应该就是最边上的吧，也就是K,L,F这些😃

**庆哥：** 完全正确，说白了，叶子节点就是那些没有子节点的节点，那么我们再来看，怎么判断哪个是根节点呢？

**小白：** 这个，我看看，应该就是没有父节点的话就是根节点吧😏

**庆哥：** 很正确啊😁，根节点的判断依据就是如果一个结点没有父结点，那么这个结点就是整棵树的根结点。好了，我们继续说其他概念

## 子树和空树

**庆哥：** 这里的子树其实就可以根据子节点来说，比如上图，A是根节点，但是如果你单看节点 B、E、F、K、L 组成的部分来说，也是一棵树，而且节点 B 为这棵树的根结点。所以称 B、E、F、K、L 这几个结点组成的树为整棵树的子树；同样，结点 E、K、L 构成的也是一棵子树，根结点为 E。

肿么样，这也好理解吧😃

**小白：** 嗯嗯，不过这里我有个疑问啊，那这样的话，一个单个节点是不是也可以看做是一棵树呢？只不过是一颗光秃秃的树😅

**庆哥：** 这个问题提的可以啊，这里要注意，正如你想的那样，单个结点也是一棵树，只不过根节点就是它本身。图 中，节点 K、L、F 等都是树，且都是整棵树的子树。

那啥是空树知道不😏

**小白：** 这个啊，就是啥数据都没有吧，没有任何节点，一个空集合吧。

**庆哥：** 非常正确，这里再补充一点，你可以看图，有没有发现，具有同一个根节点的子树是互不联系的，也就是各个子树之间不能有交集，就比如图中，我们可以看到除了根节点 A，其余各个数据又各自构成了三个子树，根结点分别为 B、C、D，这三个子树相互之间没有相同的节点。如果有的话，那就破坏了树的结构，不能算做是一棵树。

**小白：** 嗯嗯，这点确实需要好好记一下！

## 节点的度和层次

**庆哥：** 我们接着来说树的另外两个概念，那就是度和层次，这又是啥嘞，我们在上面已经分析了什么是子树，那么度就好理解了：

> 度：对于一个节点而言，拥有的子树数称为节点的度（Degree）。比如，图中根节点 A 下分出了 3 个子树（BCD），所以，结点 A 的度为 3。

这也好理解吧，有个例子一看就明白了，这里说的是针对单个节点来说，那么对于一棵树而言，它的度是多少呢？

> 树的度：一棵树的度是树内各节点的度的最大值。图 中，各个节点的度的最大值为 3，所以，整棵树的度的值是 3。

咋样，理解不😅

**小白：** 嗯嗯，看着图很好理解这些概念😃

**庆哥：** 嗯嗯，那继续说层次，也就是节点的层次，这个更好理解，看图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200114010029197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
是不是很好理解，然后这里还有个概念，那就是树的深度也可以叫高度

### 树的高度（深度）
那什么是深度（高度）呢？

> 一棵树的深度（高度）是树中节点所在的最大的层次。上图树的深度为 4。

对了上面好像没有说什么是兄弟节点：

> 如果两个节点的父节点虽不相同，但是它们的父节点处在同一层次上，那么这两个节点互为堂兄弟，也即是兄弟节点，比如，节点 G 和 E、F、H、I、J 的父结点都在第二层，所以之间为堂兄弟的关系。

ok，这些概念也讲清楚了吧😏

**小白：** 没问题的😁

## 有序树和无序树
**庆哥：** 咱们这里再来谈两个概念，就是有序树和无序树，这又是什么呢？

你看啊，如果树中节点的子树从左到右看，谁在左边，谁在右边，是有规定的，那么这棵树称为有序树；反之就称为无序树，你看这也好理解吧

基于此，就有新的概念了，在有序树中，一个节点最左边的子树称为"第一个孩子"，最右边的称为"最后一个孩子"。

举例来说，如果上图中的树其本身是一棵有序树，则以节点 B 为根节点的子树为整棵树的第一个孩子，以节点 D 为根节点的子树为整棵树的最后一个孩子。

ok，到这里就差不多了，下面咱们来总结一下

## 总结
到了这里知道了啥是树了吧，看图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200114011049397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdGh1YW5ncWluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)
对于树这种存储结构啊，它从逻辑上来看，就类似我们生活中见到的树一样，只不过是倒过来的，而且我们在了解了关于树的一些概念之后，比如父子节点这些，是不是感觉更像我们熟知的家族图谱一样，每个节点之间有这样的父子，兄弟关系。

经过上面的讲解，对于树啊，你要知道各种节点是怎么一回事，然后还要会计算各个几点的度和层次，当然树的深度也必须要知道。

关于树啊，这才是刚刚开始，知识先了解基础概念，后面还有很多内容嘞，比如二叉树，红黑树，我猜你肯定听过，这些内容我们以后再详细探讨，今天就先到！再会！🥰

# 看了这篇对二叉树的介绍，除了不会写代码啥都会！！！

> 数据结构系列的文章我们之前已经说过数组，链表，哈希表以及队列等等，上一篇也简单的介绍下了树的概念，从今天开始，我们就进入二叉树的学习，这可是面试官最喜欢的问题之一，务必掌握牢固哦！

## 回顾树的那些事
在介绍二叉树之前，我们有必要再来看看关于树的一些关键性概念，毕竟，二叉树也是树嘛。

我们首先应该了解的就是树这种数据结构属于非线性结构，然后存储的数据具有一对多的关系，这是最最基本的概念了。

### 几个概念名词要分清
然后我们需要清楚关于树的一个关键性的概念名词。

***节点***：什么是节点呢？这个节点也有叫做结点，这两个应该没有区别吧，我看过不少文章，有的叫做节点，有的叫做结点，我觉得节点更加合适，因为我们喜欢使用Node来定义一个节点，Node一般翻译过来就是节点二字。

那啥是节点：

> 简单来说，树结构存储的每一个元素都叫做一个节点

也就是在树这种结构中存储的元素都叫做节点，然后根据有些节点的特殊位置可能会有不同的叫法。

比如**根节点**，根节点只有一个，最上面的那个节点，还有**父节点**，**子节点**和**兄弟节点**，这些其实都不难理解，属于树的基础知识，不了解的可以看这篇文章，有详细的介绍：[来吧！一文彻底搞定数据结构之树！](https://blog.csdn.net/sinat_33921105/article/details/103966050)

除了节点，还有子树和空树的概念，以及节点的度和层次，树的高度或者说是深度，这些都可以在上面提到的这篇文章中找到，这里简单说下节点的度和层次，先看一个图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206230544306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
> 度：对于一个节点而言，拥有的子树数称为节点的度（Degree）。比如，图中根节点 A 下分出了 3 个子树（BCD），所以，结点 A 的度为 3。

> 树的度：一棵树的度是树内各节点的度的最大值。图 中，各个节点的度的最大值为 3，所以，整棵树的度的值是 3。

另外再提下树的高度或者深度：

> 一棵树的深度（高度）是树中节点所在的最大的层次。注意这里说的是一个树的，而不是某个节点的，因为对于一个树而言，高度从下往上和深度从上往下都是一样的，但是对于某个节点而言高度和深度就不一样了

tips：关于这些基本概念，最好就是自己完全理解，知道是怎么一回事，而不是机械的去记忆，不然即使当时记住了，要不几天也就忘得差不多了
### 英文名字Binary Tree
对了，一定要记住二叉树的英文是Binary Tree😄，接下来我们开始探讨那些你需要牢记的关于二叉树的那些知识点。

## 二叉树的特点
任何一种数据机构都有它们自己的特点，这是区别于其他数据结构，以及为什么是这样的重点所在，正式由于这些特点才能规定它叫二叉树，而不是什么三叉树或者四叉树。

对于二叉树来说，我们从名字上就能知道，这玩意一定跟二有关，两个叉，在树这种结构中，叉其实就是节点，那么二叉，说白了不说就是两个节点嘛

**二叉树的每个节点的度最大为2**

还记得什么是度吧，就是每个节点拥有的子树数，说白了，就是一个节点下有几个子节点，对二叉树来说，最多有俩，最多拥有两个子树，这个其实好理解，就是一个节点，最多有两个分叉，所以这里你要知道这个怎么回事

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206231530578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
看这个图，A有三个叉，E有两个叉。

然后我们继续说二叉树的另外一个特点：**左右节点是有顺序的**，这个啥意思嘞，就是对于二叉树来说，它的左右节点是有序的，不同顺序就不是同一个二叉树。我们继续看上面的图，假如以E为根节点，K和L为叶子节点是一颗二叉树，那么现在K在左，L在右，但是如果换换位置，K在右，L在左的话那就成了一个新的二叉树了。

这也是二叉树的一个特点。

然后依据上面这个特点，我们自然能够知道，即时某个节点只有一个子树，那么也得区分左右，不然就是两个不同的二叉树。

## 二叉树的性质
接下来我们继续分析二叉树的一些性质，其实吧，关于二叉树的性质，我看其他人写的文章介绍了好几个，觉得麻烦，有些觉得没必要啊，记住主要的两个不叫ok（也许以后会打脸）

所以嘞，我这里就说两个关于二叉树的性质，我们还要借助一个二叉树的图来看：

![图片来漫画算法](https://img-blog.csdnimg.cn/20200206232544390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
看这么一个二叉树，这里一共有三层，知道这个怎么分层的吧，然后它有这么一条性质：

> 非空二叉树的第i层，最多有2的i-1次方个节点，i是大于等于1的

咋样，对照着上面的图，自己试试看看是不是这么回事，然后还有这么一条性质：

> 在高度为h的二叉树上最多有2的h次方减一个节点

当然，二叉树的性质可不止这些，不过嘞，我这里也可以把他们全部补全，只要看看别人写的总结的，拿过来不就得了，但是觉得没啥意思，这里的性质先记住这两条，其实你只要熟悉二叉树长啥样，就能应付这些。

你想想，关于这块是不是会给你来个判断题，比如说：在高度为h的二叉树上最多有2的h次方减一个节点，你说对不对😂

这块先这么学就得了，毕竟下面还有几个让你糊涂的玩意嘞！

## 几种二叉树，容易糊涂
对于二叉树来说，它有几种特殊的形态，比如真二叉树，满二叉树和完全二叉树，这几个概念不知道大家听过没有。满二叉树的出场率应该搞一点吧，这几种二叉树可真的是会让人搞糊涂啊，特别容易张冠李戴（哈哈，突然想起来这个词）

所以嘞，接下来我绝不是简单的机械的去介绍这几种二叉树的定义，这样说了没啥意思，谁都会，网上搜搜，看看定义不就得了，也不至于在这里听我废话啊，所以，我得跟大家说说我的理解，我是怎么理解这几种二叉树的，有什么好的无别方法没有。

### 真二叉树
首先看看什么是真二叉树，真一般就是对应着假吧，这里说真二叉树，大致是不是在强调真的有两个叉呢？😂如果没有俩叉是不是就是假的了。

其实我们就可以这样理解，所谓的真二叉树，意思就是**所有的节点的度要么是0，要么都是2**，你看看，这说的不就是二叉树吗？（**可不是哦**）

### 啥是二叉树（忘了说？）
我们上面说了二叉树的特点啊，性质啊，好像还没说啥是二叉树嘞？那啥是二叉树啊？二叉树肯定是树，只不过是一种特殊的树，对于二叉树来说，它的节点最多有两个孩子节点，注意这里说的是最多有两个，那么，可能有一个，也可能一个都没有。

不行，得把重点强调一下：
> 对于二叉树来说，它的节点最多有两个孩子节点，注意这里说的是最多有两个，那么，可能有一个，也可能一个都没有。

然后你再看什么是真二叉树？

> 所有的节点的度要么是0，要么都是2

整出来区别了吧

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206234356200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
这样的叫做二叉树，但可不是真二叉树，因为这货一个叉都没有

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206234557203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
### 庆哥你竟然坑人？
等等……我说的对吗？好像有问题啊，我们再来看看什么是真二叉树：

> 所有的节点的度要么是0，要么都是2

然后再看看图，好像没啥问题啊，好像也有问题啊，怎么回事嘞？实际上，我上面说的是错的，我们这里要注意叶子节点啊，你想想，既然是叶子节点，那它肯定没有子节点啦，所以上面那个即是二叉树，也是真二叉树，因为这货人家已经是叶子节点了

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206234557203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
但是如果是这样的就不对了

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206234922817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)

这个只能是二叉树（节点可以有一个子节点），但是却不是真二叉树了，因为真二叉树要求，除了叶子节点，要么一个叉没有（成了叶子节点），要么你就俩叉。

仔细想想明白了没有，上面故意说错，不是有意误导大家，只是为了让大家记忆的更加深刻，不知道大家体会到了我的良苦用心没😂

### 满二叉树
接下来我们来看看啥又是满二叉树，我们先来猜猜，这里的形容词应该是一个“满”字，那意思就是全部都是的意思吧，大概就是这样，那放到二叉树里面，是不是说这里的叉都是满的，对于二叉树来说，就是满不也就俩叉吗？

哦哦，晓得了，也就是每个节点都是俩叉（注意，凡是这样说，我们都是不把叶子节点包含在内的），但是，如果这样的话，好像就成了真二叉树了吧。

等等，这上面可都是我们猜的啊，那实际的是咋回事嘞？

> 满二叉树：所有节点的度要么都是0 ，要么都是2，这个其实就是真二叉树的定义，但是满二叉树多了一个条件，就是满二叉树还要求所有的叶子节点都在最后一层

你看，我们知道了什么是真二叉树之后再看这个定义，觉得没啥难理解的吧，这里相比较真二叉树来说就多了这么一个条件：

> 满二叉树还要求所有的叶子节点都在最后一层

这个最后一层怎么理解？这属于基础知识吧，知道怎么分层吧，再来看看

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206230544306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)

这你可得注意啦，上面图中的可不是二叉树哦，只是让你看看怎么分层的，所以这一个自然不是满二叉树

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206234356200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
因为不在一层啊，那这个嘞

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206234922817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
这个好像都是在一层了，但是也不是，为啥，满二叉树人家要求节点得有俩叉啊，你这里虽然都在一层了，但是右边这货只有一个差，补上一个叉就对了

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207000203489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
这就是一个满二叉树了，原谅我图画的有那么一点歪歪扭扭😂

到了这里你再想我下面说的这句话对不对？

> 满二叉树属于真二叉树

这肯定是对的啊，因为所谓的满二叉树就是在真二叉树的基础之上增加条件而来的，要知道一旦增加条件就是把范围缩小了，那肯定属于之前没有增加条件的那个大范围之内啦。

所以还有一点，在同样高度的二叉树中，满二叉树的叶子节点和总结点树一定是最多的，满二叉树一定是真二叉树，但是反过来就不行了，真二叉树不一定是满二叉树

简单来说啊，满二叉树的每个分支都是满的，而且所有叶子节点都在同一层级，不然就是真二叉树。

### 完全二叉树
好了，我们继续来说说这最后的一种特殊二叉树---完全二叉树，说实在的，这三个当中就属这个完全二叉树有点难捉摸，因为它的这个概念吧说的有点神乎其神的😂

> 对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。

你看看，你看看，这说的让我不知所措啊，简单来说啊，是这样滴：

> 对于完全二叉树来说，叶子节点只会出现在最后2层，且最后一层的叶子节点都靠左对齐。

这里我想再说一个概念，那就是叶子节点成对出现，啥意思嘞，碎玉二叉树来说，节点的子节点最多为俩，一个节点下的两个节点可以说成是成对出现，比如这样

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207001507682.png)
这个应该好理解吧，那么再看这完全二叉树，如果他的叶子节点出现在最后一层和倒数第二层，那么倒数第二层的叶子节点一定是成对出现的，最后一层可以不是成对出现，但是如果是单个必须靠左，就是这样

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207001853442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
然后我们再来看这个定义：

> 对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。

我们先把一个满二叉树编号，顺序以根节点开始，自上而下，从左到右

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207002049233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)

然后我们再看这个二叉树编上号

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207002131574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)

然后与上面那个满二叉树做对比看看

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207002230155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
这里的顺序是一一对应的，所以这个二叉树就是完全二叉树，那啥是不一一对应嘞，看这个

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207002427425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
那这就不是一个完全二叉树了。

经过了这么些分析，应该已经知道什么是完全二叉树了吧，我们看看，这些小总结：

1、完全二叉树从根节点到倒数第二层一定是一棵满二叉树

2、满二叉树一定是完全二叉树，但是完全二叉树不一定是满二叉树

然后其实对于完全二叉树还有这么些个性质：

 1. 度为1的节点只有左子树 
 2. 度为1的节点要么是1个，要么是0个 
 3. 同样节点数量的二叉树，安全二叉树的高度最小

## 三种特殊二叉树的区别于联系
首先看真二叉树和满二叉树，这个都要求每个分支节点都是满的，也就是每个节点都有两个叉，也就是左右孩子节点，当然，叶子节点除外，满足这个就是真二叉树，如果在此条件上再加上一个条件，所有叶子节点在同一层级，那就是满二叉树。

也就是说，除叶子节点，每个节点都有左右孩子节点，那就是真二叉树。
如果除此之外，所有叶子节点又都在一个层级，那就是满二叉树

对于完全二叉树，叶子节点只能在最后两层，且除了最后一层的叶子节点，其他节点都是满的，也就是如果倒数第二层也有叶子节点，那一定是左右孩子节点齐全的（成对出现），最后一层的叶子节点可以是不满的，但是只能是左孩子

好啦，这三个货，大家要好好理解理解哦！

## 如何存储二叉树
这相对来说是个难点，需要动脑子思考，不然不好理解

首先要知道，**数据结构分为物理结构和逻辑结构**，像数组这种数据结构就属于物理结构，人家是怎么样的就在内存中怎么存储，但是对于逻辑结构比如这里的二叉树，貌似就没法直接存了，不过逻辑结构的数据结构可以使用多种物理结构来存储

一般来说，就是数组和链表，这俩万能啊，很多东东的底层貌似都有这俩货。

所以对于二叉树也是一样的，可以使用链表和数组来存储。

### 使用链表来存储
使用链表来存储树结构数据，好像是最直观的了，看个图

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020020700302252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
也就是说每个节点包含三部分，一个是该节点保存的数据，两外两个分别是保存的该节点左右孩子节点的内存地址，这样看起来很直观，和树结构原来的样子很接近。

回顾一下链表的知识，链表也就是一个接一个，每个链表节点包含一个data变量和一个next指针，这里对于二叉树来说，包含两个next指针，因为要指向左右孩子节点。

我们接下来再看使用数组怎么来存储二叉树

### 使用数组来存储
数组相对来说，就没有那么直观了，要想理解二叉树的数组的存储方式，必须先在脑海中建立这样的一个观念：

***那就是，二叉树的每个节点从跟节点开始都有自己对应的编号***

为啥，数组不是有下标吗？一一对应啊这是。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207003306638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
也就是按照一个满二叉树去想象，从根节点开始给每个节点编号，从左到右，从上到下，然后依次放到数组的对应位置中，需要注意的是，数组是从0开始计算的。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207003325849.png)
也就是说，根节点是放到0这个位置上的，上面这个情况就是按照顺序依次存储，可能还有这样的情况

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207003343401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
就是二叉树不是一个满二叉树，另外这个二叉树既不是满二叉树，也不是完全二叉树，更不是真二叉树，就是普通的一个二叉树

这个该怎么存储，看图

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207003402716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
很简单，把对应的位置空出来，也就是说，二叉树本来那地方有个6位置的数据，但是现在没有了，对应应该是数组下标为5的位置，既然没有那就为空即可。

为啥要这样嘞，因为这样可以保持和二叉树的位置一一对应，这样我们就能按照二叉树的一些性质去定位二叉树中的某些节点了。

然后就有下面这一些公式可以方便求解二叉树的父节点和左右节点


> 如果一个父节点的下标是index，那么它的的左节点下标就是2index+1 右节点下标就是2index+2


反过来是一样的道理


> 如果一个左节点的下标是leftindex 那么它的父节点就是（leftindex-1）/2


但是这里你就会发现，对于这样的表示，如果一个二叉树，很多位置都是空的，那对应的数组位置也是空的，而数组申请内存空间，一旦申请，不会改变，那就浪费内存空间了

所以得考虑，什么样的二叉树适合用数组来存储！

好啦好啦，就说到这啦，毕竟下面还有很多嘞！

## 二叉树的应用
我们上面巴拉巴拉说了一大堆，那么这个二叉树到底有啥用啊，还搞的怪麻烦，在实际中，二叉树的作用主要有两部分：

1、用于查找
2、用于维持相对顺序

啥意思嘞，听我慢慢解释。

### 用于查找
二叉树的每个节点其实都可以看做是个索引，所以二叉树这种数据结构很适合用来查找，这里有一种特殊的二叉树结构，叫二叉查找树，主要作用就是用来进行查找的

既然是二叉树的一种特殊结构，那相对二叉树还是有些不同的地方的：

1、如果左子树不为空，那么左子树上所有节点的值均小于根节点的值
2、如果右子树不为空，那么右子树上所有节点的值均大于根节点的值
3、左右子树也都是二叉查找树

也就是规定了节点上的值，左边的都比根节点小，右边的都比根节点大，这样的话就会产生两个极值，左下角的是最小的那个，右下角是最大的那个

以此，就可以比较快速的查找一个值，可以把要查找的值与根节点的值进行比较，然后看是与左节点比较，还是与有节点比较，有一种猜数，大了还是小了的那种意思。

关于二叉查找树，我们以后会单独介绍的。

### 用于维持相对顺序
二叉茶查找树对节点的值有了规定，因此，节点的数据都是有顺序的，所以二叉查找树还叫做二叉排序树，这里的维持相对顺序啥意思嘞

就是如果你要新插入一个新的值的话还是要按照这个规定把新值放到合适的位置上

但是在插入的时候可能会出现的一个问题就是全部插入到左节点上了，比如根节点是10，然后插入9,8,7,6,5,4就会变成这个样子

![（图片来源：漫画算法）](https://img-blog.csdnimg.cn/20200207004002426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
这就牵扯到二叉树的自平衡了，自平衡的方式有很多种，比如红黑树（重点），AVL树和树堆等等。

这些个知识点，也都很重要且内容比较多，以后单独写文章介绍（持续关注我的公众号：编码之外，避免失联）

## 二叉树的遍历
接下来就到了二叉树的遍历这块了，关于这块其实首要任务就是搞清楚几个比较容易混淆的遍历方式，也不是混淆，就是容易忘记😂

对于二叉树的遍历可以分为两种方式，一种是按照节点位置的关系去遍历，还有一种是按宏观角度去遍历，在宏观的……我去，还是看个图吧

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207004403989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
看吧，它的遍历就是这么回事，我们接下来慢慢说😂

### 前序遍历
前序遍历记住输出顺序是：**根节点，左子树，右子树**

按照这个顺序去遍历，这里还要理解的一点就是，比如遍历到根节点，然后去遍历根节点的左子树，当遍历完左子树以后不是马上去遍历右子树，而是看看左子树是否还有左子树，理解这个相当重要。

![来源漫画算法](https://img-blog.csdnimg.cn/20200207004608399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
看看图，理解一下，图中的黑色编号就是前序遍历的顺序。

### 中序遍历
输出顺序：左子树，根节点，右子树

对于中序遍历的理解同前序遍历，另外需要补充一点，遍历是从根节点开始按照顺序遍历，看看图：

![来源漫画算法](https://img-blog.csdnimg.cn/20200207004808317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
### 后序遍历
**输出顺序是左子树、右子树、根节点。**

继续看看图：

![来源漫画算法](https://img-blog.csdnimg.cn/2020020700491811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
### 层序遍历
层序遍历听着不好理解，但是实际的输出顺序最好理解，就是按照从根节点到各个节点的层次关系一次输出，还记得之前给满二叉树编号吗？

从根节点开始，从上到下，从左到右

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207005043833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMzOTIxMTA1,size_16,color_FFFFFF,t_70)
这个最好理解啦

## 深度优先与广度优先
这里简单说下深度优先与广度优先，这是咋么个意思嘞？

**深度优先，深度深度，就是深入的意思，类似一头扎到底的那个意思**

至于广度优先嘛，广度优先讲究的是一个横切面，**广度，面要广，不要一头扎到底**，和深度优先正好相反！

好啦，到了这里就差不多了，理解了上面这些，出去跟面试官扯皮没问题了，但是，如果让你上手写代码，那你就挂了，别担心，后面会出一篇专门讲二叉树相关的各种代码编码的，比如各种遍历，以及存储等等！

